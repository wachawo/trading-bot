(Files content cropped to 300k characters, download full ingest to see more)
================================================
FILE: README.md
================================================
# apex omni

Official Python3 API connector for Apex omni's HTTP and WebSockets APIs.  
You can get Api information from 
[OpenApi-SDK](https://api-docs.pro.apex.exchange/#introduction)

## About
Put simply, `apex omni` is the official lightweight one-stop-shop module for the Apex omni HTTP and WebSocket APIs. 

## Development
- `apex omni` is being actively developed, and new API changes should arrive on `apex omni` very quickly. `apex omni` uses `requests` and `websocket` for its methods, alongside other built-in modules. Anyone is welcome to branch/fork the repository and add their own upgrades. If you think you've made substantial improvements to the module, submit a pull request and we'll gladly take a look.      

## Installation
`apex omni` supports Python versions from 3.6 to 3.12. The module can be installed manually or via [apexomni](https://pypi.org/project/apexomni/)  with `pip`:
```
pip3 install apexomni
```
## New Basic Usage V3 
You can create an HTTP session for Inverse on APEX_OMNI_HTTP_TEST or APEX_OMNI_HTTP_MAIN:

```python
from apexomni.constants import APEX_OMNI_HTTP_TEST
from apexomni.http_public import HttpPublic

client = HttpPublic(APEX_OMNI_HTTP_TEST)
```
### Public endpoints V3

You can get no authentication information from public endpoints.  
Please refer to [demo_public_v3](https://github.com/ApeX-Protocol/apexpro-openapi/blob/main/tests/demo_public_v3.py)

The V3 version supports  USDT symbols. Users need to request the configs_v3() interface to obtain the configuration of symbols.
```python
client = HttpPublic(APEX_OMNI_HTTP_MAIN)
print(client.configs_v3())
print(client.klines_v3(symbol="ETHUSDT",interval=5,start=1718358480, end=1718950620, limit=5))
print(client.depth_v3(symbol="BTCUSDT"))
print(client.trades_v3(symbol="BTCUSDT"))
print(client.klines_v3(symbol="BTCUSDT",interval="15"))
print(client.ticker_v3(symbol="BTCUSDT"))
print(client.history_funding_v3(symbol="BTC-USDT"))
```

### Register OMNI method V3
- You can get zkKeys from client.derive_zk_key(), for regiter-user, create-order or transfer and withdraw.    
- If the user wants to trade OMNI's symbols, needs to call the register_user_v3() interface to register a OMNI account.   
- If the user has previously registered a pro apex account using the v1 or v2 interface, you also need to use the register_user_v3()   
    interface to register again.        
- You need to call client.configs_v3() after init client.      
- You can get apiKey and accountId for private Api    
- After call register_user_v3(), the user must call change_pub_key_v3() to complete register v3 account.   
- Since the register_user_v3  is a non-blocking process, you need to sleep for 10 sec before call the change_pub_key_v3() action.
Please refer to [demo_register_v3](https://github.com/ApeX-Protocol/apexpro-openapi/blob/main/tests/demo_register_v3.py)

```python
from apexomni.constants import APEX_OMNI_HTTP_MAIN, NETWORKID_OMNI_MAIN_ARB, NETWORKID_MAIN

print("Hello, Apex Omni")
priKey = "your eth private key"

client = HttpPrivate_v3(APEX_OMNI_HTTP_MAIN, network_id=NETWORKID_MAIN, eth_private_key=priKey)
configs = client.configs_v3()

zkKeys = client.derive_zk_key(client.default_address)
print(zkKeys)

nonceRes = client.generate_nonce_v3(refresh="false", l2Key=zkKeys['l2Key'], ethAddress=client.default_address,
                                    chainId=NETWORKID_OMNI_MAIN_ARB)

regRes = client.register_user_v3(nonce=nonceRes['data']['nonce'], l2Key=zkKeys['l2Key'], seeds=zkKeys['seeds'],
                                 ethereum_address=client.default_address)

key = regRes['data']['apiKey']['key']
secret = regRes['data']['apiKey']['secret']
passphrase = regRes['data']['apiKey']['passphrase']

time.sleep(10)
accountRes = client.get_account_v3()
print(accountRes)

# back zkKeys, apiKey,and accountId for private Api or create-oreder transfer or withdraw

print(regRes['data']['account']['id'])
print(regRes['data']['apiKey'])

changeRes = client.change_pub_key_v3(chainId=NETWORKID_OMNI_MAIN_ARB, seeds=zkKeys.get('seeds'), ethPrivateKey=priKey,
                                     zkAccountId=accountRes.get('spotAccount').get('zkAccountId'),
                                     subAccountId=accountRes.get('spotAccount').get('defaultSubAccountId'),
                                     newPkHash=zkKeys.get('pubKeyHash'),
                                     nonce=accountRes.get('spotAccount').get('nonce'), l2Key=zkKeys.get('l2Key'))
print(changeRes)

time.sleep(10)
accountRes = client.get_account_v3()
print(accountRes)
```

### Private endpoints V3
Users need to request the configs_v3() and get_account_v3() interface to obtain the configuration of Account.   

some authentication information is required to access private endpoints.   
Please refer to [demo_private_v3](https://github.com/ApeX-Protocol/apexpro-openapi/blob/main/tests/demo_private_v3.py)

```python
from apexomni.constants import APEX_OMNI_HTTP_MAIN,
    NETWORKID_OMNI_MAIN_ARB

print("Hello, Apex Omni")
# need api_key_credentials={'key': key,'secret': secret, 'passphrase': passphrase} for private api

key = 'your apiKey-key from register V3'
secret = 'your apiKey-secret from register  V3'
passphrase = 'your apiKey-passphrase from register  V3'

client = HttpPrivate_v3(APEX_OMNI_HTTP_MAIN, network_id=NETWORKID_OMNI_MAIN_ARB,
                        api_key_credentials={'key': key, 'secret': secret, 'passphrase': passphrase})
configs = client.configs_v3()

userRes = client.get_user_v3()
print(userRes)

accountRes = client.get_account_v3()
print(accountRes)

accountBalanceRes = client.get_account_balance_v3()
print(accountBalanceRes)

fillsRes = client.fills_v3(limit=100, page=0, symbol="BTC-USDT", side="BUY", token="USDT")
print(fillsRes)

transfersRes = client.transfers_v3(limit=100)
print(transfersRes)

transferRes = client.transfer_v3(ids='586213648326721628')
print(transferRes)

transfersRes = client.contract_transfers_v3(limit=100)
print(transfersRes)

transferRes = client.contract_transfer_v3(ids='588301879870489180')
print(transferRes)

# deleteOrderRes = client.delete_order_v3(id="588302655921587036")
# print(deleteOrderRes)

# deleteOrderRes = client.delete_order_by_client_order_id_v3(id="123456")
# print(deleteOrderRes)

openOrdersRes = client.open_orders_v3()
print(openOrdersRes)

deleteOrdersRes = client.delete_open_orders_v3(symbol="BTC-USDT", )
print(deleteOrdersRes)

historyOrdersRes = client.history_orders_v3(token='USDT')
print(historyOrdersRes)

getOrderRes = client.get_order_v3(id="123456")
print(getOrderRes)

getOrderRes = client.get_order_by_client_order_id_v3(id="123456")
print(getOrderRes)

fundingRes = client.funding_v3(limit=100)
print(fundingRes)

historicalPnlRes = client.historical_pnl_v3(limit=100)
print(historicalPnlRes)

yesterdayPnlRes = client.yesterday_pnl_v3()
print(yesterdayPnlRes)

historyValueRes = client.history_value_v3()
print(historyValueRes)

setInitialMarginRateRes = client.set_initial_margin_rate_v3(symbol="BTC-USDT", initialMarginRate="0.05")
print(setInitialMarginRateRes)

```

### zkKey sign withdraw or transfer method
Users need to request the configs_v3() and get_account_v3() interface to obtain the configuration of Account.    

Several endpoints require a seeds and l2Key signature authentication, namely as following:    
- create_withdrawal_v3()  to withdraw or fast withdraw
- create_transfer_out_v3()   to transfer asset from spot account to contract account   
- create_contract_transfer_out_v3()   to transfer asset from contract account to spot account    

Please refer to [demo_transfer_v3](https://github.com/ApeX-Protocol/apexpro-openapi/blob/main/tests/demo_transfer_v3.py)

```python
key = 'your apiKey-key from register'
secret = 'your apiKey-secret from register'
passphrase = 'your apiKey-passphrase from register'

seeds = 'your zk seeds from register'
l2Key = 'your l2Key seeds from register'

client = HttpPrivateSign(APEX_OMNI_HTTP_TEST, network_id=NETWORKID_TEST,
                          zk_seeds=seeds,zk_l2Key=l2Key,
                          api_key_credentials={'key': key, 'secret': secret, 'passphrase': passphrase})
configs = client.configs_v3()
accountData = client.get_account_v3()

#smple1 withdraw
#createWithdrawRes = client.create_withdrawal_v3(amount='3',asset='USDT', toChainId=3)
#print(createWithdrawRes)

#smple2 fast withdraw
#withdraw_feeRes = client.withdraw_fee_v3(amount="3",chainIds="3",tokenId='140')
#print(withdraw_feeRes)
#createWithdrawRes = client.create_withdrawal_v3(amount='3',asset='USDT', toChainId=3, fee=withdraw_feeRes.get('data').get('withdrawFeeAndPoolBalances')[0].get('fee'), isFastWithdraw=True)
#print(createWithdrawRes)

#smple3 transfer_out
#createTransferRes = client.create_transfer_out_v3(amount='3.4359738368',asset='USDT')
#print(createTransferRes)

#smple4 contract transfer_out
createContractTransferRes = client.create_contract_transfer_out_v3(amount='3.4359738368',asset='USDT')
print(createContractTransferRes)

```


### zkKey sign create order method
Users need to request the configs_v3() and get_account_v3() interface to obtain the configuration of Account.    
Several endpoints require a seeds and l2Key signature authentication, namely as following:    
- create_order_v3()  to create order

```python
from apexomni.constants import NETWORKID_TEST, APEX_OMNI_HTTP_TEST

print("Hello, Apex omni")

key = 'your apiKey-key from register'
secret = 'your apiKey-secret from register'
passphrase = 'your apiKey-passphrase from register'

seeds = 'your zk seeds from register'
l2Key = 'your l2Key seeds from register'

client = HttpPrivateSign(APEX_OMNI_HTTP_TEST, network_id=NETWORKID_TEST,
                         zk_seeds=seeds, zk_l2Key=l2Key,
                         api_key_credentials={'key': key, 'secret': secret, 'passphrase': passphrase})
configs = client.configs_v3()
accountData = client.get_account_v3()

currentTime = time.time()
createOrderRes = client.create_order_v3(symbol="BTC-USDT", side="SELL",
                                        type="MARKET", size="0.001", timestampSeconds=currentTime,
                                        price="60000")
print(createOrderRes)

# sample6
# Create a  TP/SL order
# first, Set a slippage to get an acceptable slPrice or tpPrice
#slippage is recommended to be greater than 0.1
# when buying, the price = price*(1 + slippage). when selling, the price = price*(1 - slippage)
slippage = decimal.Decimal("-0.1")
slPrice = decimal.Decimal("58000") * (decimal.Decimal("1") + slippage)
tpPrice = decimal.Decimal("79000") * (decimal.Decimal("1") - slippage)

createOrderRes = client.create_order_v3(symbol="BTC-USDT", side="BUY",
                                        type="LIMIT", size="0.01",
                                        price="65000",
                                        isOpenTpslOrder=True,
                                        isSetOpenSl=True,
                                        slPrice=slPrice,
                                        slSide="SELL",
                                        slSize="0.01",
                                        slTriggerPrice="58000",
                                        isSetOpenTp=True,
                                        tpPrice=tpPrice,
                                        tpSide="SELL",
                                        tpSize="0.01",
                                        tpTriggerPrice="79000",
                                        )
print(createOrderRes)

print("end, Apexomni")

```

### WebSocket
To see comprehensive examples of how to subscribe topics from websockets.
Please refer to [demo_ws_v3](https://github.com/ApeX-Protocol/apexpro-openapi/blob/main/tests/demo_ws_v3.py)


```python
from time import sleep

from apexomni.constants import APEX_OMNI_WS_MAIN
from apexomni.websocket_api import WebSocket

key = 'your apiKey-key from register V3'
secret = 'your apiKey-secret from register  V3'
passphrase = 'your apiKey-passphrase from register  V3'


# Connect with authentication!
# APEX_OMNI_WS_MAIN for mainnet, APEX_OMNI_WS_TEST for testnet
ws_client = WebSocket(
    endpoint=APEX_OMNI_WS_MAIN,
    api_key_credentials={'key': key, 'secret': secret, 'passphrase': passphrase},
)

def handle_account(message):
    print(message)
    contents_data = message["contents"]
    print(len(contents_data))

def h1(message):
    print(1, message)
def h2(message):
    print(2, message)
def h3(message):
    print(3, message)
def h4(message):
    print(4, message)

#ws_client.depth_stream(h1,'BTCUSDT',25)
#ws_client.ticker_stream(h2,'BTCUSDT')
ws_client.trade_stream(h3,'BTCUSDT')
ws_client.klines_stream(h4,'BTCUSDT',1)
ws_client.account_info_stream_v3(handle_account)


while True:
    # Run your main trading logic here.
    sleep(1)




================================================
FILE: CHANGELOG.md
================================================
# Changelog

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [1.0.0] - 2022-06-03

### Added

- The `apexpro` module.
- MANIFEST, README, LICENSE, and CHANGELOG files.



================================================
FILE: LICENSE
================================================
MIT License

Copyright for portions of aprxomni are held by verata-veritatis, 2020. Since
version 2.0.0, all other copyright are held by apex.exchange, 2033.

Copyright (c) 2020 verata-veritatis

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.



================================================
FILE: MANIFEST.in
================================================
include LICENSE
include README.md
include CHANGELOG.md
include setup.cfg
include tox.ini
include pyproject.toml
recursive-include apexomni *.json
recursive-include apexomni *.dylib
recursive-include apexomni *.dll
recursive-include apexomni *.so



================================================
FILE: PKG-INFO
================================================
Metadata-Version: 2.4
Name: ApexOmni
Version: 3.1.0
Summary: Python3 ApexOmni HTTP/WebSocket API Connector
Home-page: https://github.com/ApeX-Protocol/apexpro-openapi
Author: Dexter Dickinson
License: MIT License
Keywords: apex omni api connector
Platform: UNKNOWN
Classifier: Development Status :: 4 - Beta
Classifier: Intended Audience :: Developers
Classifier: Topic :: Software Development :: Libraries :: Python Modules
Classifier: License :: OSI Approved :: MIT License
Classifier: Programming Language :: Python :: 3.6
Classifier: Programming Language :: Python :: 3.7
Classifier: Programming Language :: Python :: 3.8
Classifier: Programming Language :: Python :: 3.9
Classifier: Programming Language :: Python :: 3.10
Classifier: Programming Language :: Python :: 3.11
Classifier: Programming Language :: Python :: 3.12
Requires-Python: >=3.6
Description-Content-Type: text/markdown
License-File: LICENSE




================================================
FILE: pyproject.toml
================================================
[build-system]
requires = ["setuptools>=42", "wheel"]
build-backend = "setuptools.build_meta"

[project]
name = "apexomni-x86-mac"
version = "3.1.0"
description = "Python3 Apexpro omni HTTP/WebSocket API Connector"
authors = [
    {name = "Dexter Dickinson", email = "xxx@apexomni.com"}
]
readme = "README.md"
requires-python = ">=3.6"
classifiers = [
    "Development Status :: 4 - Beta",
    "Intended Audience :: Developers",
    "Topic :: Software Development :: Libraries :: Python Modules",
    "License :: OSI Approved :: MIT License",
    "Programming Language :: Python :: 3.6",
    "Programming Language :: Python :: 3.7",
    "Programming Language :: Python :: 3.8",
    "Programming Language :: Python :: 3.9",
    "Programming Language :: Python :: 3.10",
    "Programming Language :: Python :: 3.11",
    "Programming Language :: Python :: 3.12",
]

[tool.pytest.ini_options]
testpaths = ["tests"]
python_files = ["test_*.py"]
addopts = "-ra -q"

[tool.black]
line-length = 88
target-version = ['py36', 'py37', 'py38', 'py39', 'py310', 'py311', 'py312']
include = '\.pyi?$'

[tool.isort]
profile = "black"
multi_line_output = 3



================================================
FILE: README_V2.md
================================================
# apexpro

Official Python3 API connector for Apexpro's HTTP and WebSockets APIs.  
You can get Api information from 
[OpenApi-SDK](https://api-docs.pro.apex.exchange/#introduction)

## About
Put simply, `apexpro`  is the official lightweight one-stop-shop module for the Apex pro HTTP and WebSocket APIs. 

## Development
`apexpro` is being actively developed, and new API changes should arrive on `apexpro` very quickly. `apexpro` uses `requests` and `websocket` for its methods, alongside other built-in modules. Anyone is welcome to branch/fork the repository and add their own upgrades. If you think you've made substantial improvements to the module, submit a pull request and we'll gladly take a look.

## Installation
`apexpro` requires Python 3.6.1 - Python 3.10.0 . The module can be installed manually or via [apexpro](https://pypi.org/project/apexpro/) with `pip`:
```
pip3 install apexpro
```

## New Basic Usage V2 
You can create an HTTP session for Inverse on APEX_HTTP_TEST or APEX_HTTP_MAIN:

```python
from apexomni.constants import APEX_HTTP_TEST
from apexomni.http_public import HttpPublic

client = HttpPublic(APEX_HTTP_TEST)
```
### Public endpoints V2

You can get no authentication information from public endpoints.  
Please refer to [demo_public_v2](https://github.com/ApeX-Protocol/apexpro-openapi/blob/main/tests/demo_public_v2.py)

The V2 version supports both USDT and USDC symbols. Users need to request the configs_v2() interface to obtain the configuration of symbols.

```python
from apexomni.constants import APEX_HTTP_TEST, APEX_HTTP_MAIN
from apexomni.http_public import HttpPublic

client = HttpPublic(APEX_HTTP_MAIN)
print(client.configs_v2())
print(client.history_funding_v2(symbol="BTC-USDT"))
print(client.klines(symbol="ETHUSDT", interval=5, start=1681463600, end=1681563600, limit=5))
print(client.server_time())
print(client.depth(symbol="BTC-USDC"))
print(client.trades(symbol="BTC-USDC"))
print(client.klines(symbol="BTC-USDT", interval="15"))
print(client.ticker(symbol="BTC-USDT"))
print(client.history_funding(symbol="BTC-USDT"))

print(client.depth(symbol="ETH-USDT", limit=50))
print(client.trades(symbol="ETH-USDT", limit=50))
print(client.klines(symbol="ETH-USDT", interval="15"))
print(client.history_funding_v2(symbol="ETH-USDT", limit=100, page=0, beginTimeInclusive=1662348573000,
                                endTimeExclusive=1662434973000))
```

### Register  method V2
If the user wants to trade USDT symbols, needs to call the register_user_v2() interface to register a USDT account, 
and fill in 'USDT' for the token parameter. In the same way, to trade USDC symbols, 
call the register_user_v2() interface to register a USDC account, and fill in 'USDC' as the token parameter. 
If the user has previously registered a USDC account using the v1 interface, there is no need to use the register_user_v2() 
interface to register again.      
You need to call client.configs_v2() after init client.   
You can get stark_key_pair, apiKey,and accountId for private Api , create-order and withdraw  
Please refer to [demo_register_v2](https://github.com/ApeX-Protocol/apexpro-openapi/blob/main/tests/demo_register_v2.py)

```python
from apexomni.http_private import HttpPrivate
from apexomni.constants import APEX_HTTP_TEST, NETWORKID_TEST, APEX_HTTP_MAIN, NETWORKID_MAIN

priKey = "your eth private key"

client = HttpPrivate(APEX_HTTP_TEST, network_id=NETWORKID_TEST, eth_private_key=priKey)
configs = client.configs_v2()

stark_key_pair_with_y_coordinate = client.derive_stark_key(client.default_address)
nonceRes = client.generate_nonce(starkKey=stark_key_pair_with_y_coordinate['public_key'],
                                 ethAddress=client.default_address, chainId=NETWORKID_TEST)

regRes = client.register_user_v2(token='USDT', nonce=nonceRes['data']['nonce'],
                                 starkKey=stark_key_pair_with_y_coordinate['public_key'],
                                 stark_public_key_y_coordinate=stark_key_pair_with_y_coordinate[
                                     'public_key_y_coordinate'], ethereum_address=client.default_address)
key = regRes['data']['apiKey']['key']
secret = regRes['data']['apiKey']['secret']
passphrase = regRes['data']['apiKey']['passphrase']

# back stark_key_pair, apiKey,and accountId for private Api or create-order or withdraw
print(stark_key_pair_with_y_coordinate)
print(regRes['data']['account']['positionId'])
print(regRes['data']['apiKey'])
```

### Private endpoints V2
The V2 version supports both USDT and USDC Account. Users need to request the configs_v2() and get_account_v2() interface to obtain the configuration of Account.

some authentication information is required to access private endpoints. 
Please refer to [demo_private](https://github.com/ApeX-Protocol/apexpro-openapi/blob/main/tests/demo_private.py)

```python
from apexomni.http_private import HttpPrivate
from apexomni.constants import APEX_HTTP_TEST, NETWORKID_TEST

# need apiKey={'key': key,'secret': secret, 'passphrase': passphrase} for private api

key = 'your apiKey-key from register'
secret = 'your apiKey-secret from register'
passphrase = 'your apiKey-passphrase from register'

client = HttpPrivate(APEX_HTTP_TEST, network_id=NETWORKID_TEST,
                     api_key_credentials={'key': key, 'secret': secret, 'passphrase': passphrase})
configs = client.configs_v2()

accountRes = client.get_account_v2()
print(accountRes)

fillsRes = client.fills_v2(limit=100, page=0, symbol="BTC-USDT", side="BUY", token="USDT")
print(fillsRes)

transfersRes = client.transfers_v2(limit=100, page=0, currencyId="USDT", chainIds="1,5,13,97")
print(transfersRes)

withdrawListRes = client.withdraw_list_v2(limit=100, page=0, beginTimeInclusive=1651406864000,
                                          endTimeExclusive=1657105971171)
print(withdrawListRes)

uncommon_withdraw_feeRes = client.uncommon_withdraw_fee_v2(amount="101000.1", token="USDT", chainId=5)
print(uncommon_withdraw_feeRes)

transfer_limitRes = client.transfer_limit_v2(currencyId="USDT")
print(transfer_limitRes)

fillsRes = client.fills_v2(limit=100, page=0, symbol="BTC-USDT", side="BUY", token="USDT")
print(fillsRes)

deleteOrderRes = client.delete_order_v2(id="123456")
print(deleteOrderRes)

deleteOrderRes = client.delete_order_by_client_order_id_v2(id="123456")
print(deleteOrderRes)

openOrdersRes = client.open_orders_v2(token='USDT')
print(openOrdersRes)

deleteOrdersRes = client.delete_open_orders_v2(symbol="BTC-USDC,ETH-USDC", token='USDT')
print(deleteOrdersRes)

historyOrdersRes = client.history_orders_v2(token='USDT')
print(historyOrdersRes)

getOrderRes = client.get_order_v2(id="123456")
print(getOrderRes)

getOrderRes = client.get_order_by_client_order_id_v2(id="123456")
print(getOrderRes)

fundingRes = client.funding_v2(limit=100, page=0, symbol="BTC-USDC", side="BUY", token='USDT')
print(fundingRes)

notifyListRes = client.notify_list(limit=100, page=0, unreadOnly="true", notifyCategory="1")
print(notifyListRes)

markNotifyReadRes = client.mark_notify_read(ids="113123,123123123")
print(markNotifyReadRes)

historicalPnlRes = client.historical_pnl_v2(limit=100, page=0, beginTimeInclusive=1651406864000,
                                            endTimeExclusive=1657105971171, symbol="BTC-USDC")
print(historicalPnlRes)

yesterdayPnlRes = client.yesterday_pnl_v2(token='USDT')
print(yesterdayPnlRes)

historyValueRes = client.history_value_v2(token='USDT')
print(historyValueRes)

markAllNotifyReadRes = client.mark_all_notify_read()
print(markAllNotifyReadRes)

setInitialMarginRateRes = client.set_initial_margin_rate_v2(symbol="BTC-USDC", initialMarginRate="0.1", token='USDT')
print(setInitialMarginRateRes)

```

### Stark key sign method
The V2 version supports both USDT and USDC Account. Users need to request the configs_v2() and get_account_v2() interface to obtain the configuration of Account.

Several endpoints require a starkKey signature authentication, namely as following:
- create-order
- withdraw

Please refer to [demo_stark_key_sign](https://github.com/ApeX-Protocol/apexpro-openapi/blob/main/tests/demo_stark_key_sign.py)

```python
import time
from apexomni.http_private_stark_key_sign import HttpPrivateStark

from apexomni.constants import APEX_HTTP_TEST, NETWORKID_TEST

# need api_key_credentials={'key': key,'secret': secret, 'passphrase': passphrase} for private api
# need starkey for withdraw and createOrder

key = 'your apiKey-key from register'
secret = 'your apiKey-secret from register'
passphrase = 'your apiKey-passphrase from register'

public_key = 'your stark_public_key from register'
public_key_y_coordinate = 'your stark_public_key_y_coordinate from register'
private_key = 'your stark_private_key from register'

client = HttpPrivateStark(APEX_HTTP_TEST, network_id=NETWORKID_TEST,
                          stark_public_key=public_key,
                          stark_private_key=private_key,
                          stark_public_key_y_coordinate=public_key_y_coordinate,
                          api_key_credentials={'key': key, 'secret': secret, 'passphrase': passphrase})
configs = client.configs_v2()
client.get_user()
print(client.get_account_v2())

print(client.get_account_balance_v2())

currentTime = time.time()

# feeRes = client.uncommon_withdraw_fee_v2(amount='2',chainId='5', token='USDT',)
# print(feeRes)
# fastWithdrawRes = client.fast_withdrawal_v2(amount='2',expirationEpochSeconds= currentTime,asset='USDT',fee=feeRes['data']['fee'])

# createWithdrawRes = client.create_withdrawal_v2(amount='1',expirationEpochSeconds= currentTime,asset='USDT')
# print(createWithdrawRes)

historyOrdersRes = client.history_orders_v2(token="USDT")
print(historyOrdersRes)

orderFills = client.order_fills_v2(orderId='498441108374684453')
print(orderFills)

limitFeeRate = '0.0005'

deleteOrdersRes = client.delete_open_orders_v2(token="USDT")
print(deleteOrdersRes)

createOrderRes = client.create_order_v2(symbol="BTC-USDT", side="SELL",
                                        type="LIMIT", size="0.01", expirationEpochSeconds=currentTime,
                                        price="36890", limitFeeRate=limitFeeRate, timeInForce="POST_ONLY")

# print(createOrderRes)

fillsRes = client.fills_v2(limit=100, page=0, symbol="BTC-USDT", token="USDT")
print(fillsRes)

openOrderRes = client.open_orders_v2(token='USDT')
print(openOrderRes)

deleteOrdersRes = client.delete_open_orders_v2(token="USDT")
print(deleteOrdersRes)

historyOrdersRes = client.history_orders_v2(token="USDT")
print(historyOrdersRes)

openOrderRes = client.open_orders_v2(token='USDT')
print(openOrderRes)

feeRes = client.uncommon_withdraw_fee_v2(amount='2', chainId='97', token='USDT')
print(feeRes)
crossWithdrawRes = client.cross_chain_withdraw_v2(amount='2', expirationEpochSeconds=currentTime, asset='USDT',
                                                  fee=feeRes['data']['fee'], chainId='97')
print(crossWithdrawRes)

```

### WebSocket
To see comprehensive examples of how to subscribe topics from websockets.
Please refer to [demo_ws](https://github.com/ApeX-Protocol/apexpro-openapi/blob/main/tests/demo_ws.py)

```python
from time import sleep

from apexomni.constants import APEX_WS_TEST
from apexomni.websocket_api import WebSocket

key = 'your apiKey-key from register'
secret = 'your apiKey-secret from register'
passphrase = 'your apiKey-passphrase from register'

# Connect with authentication!
ws_client = WebSocket(
    endpoint=APEX_WS_TEST,
    api_key_credentials={'key': key, 'secret': secret, 'passphrase': passphrase},
)


def handle_account(message):
    print(message)
    contents_data = message["contents"]
    print(len(contents_data))


def h1(message):
    print(1, message)


def h2(message):
    print(2, message)


def h3(message):
    print(3, message)


def h4(message):
    print(4, message)


#ws_client.depth_stream(h1,'BTCUSDC',25)
#ws_client.ticker_stream(h2,'BTCUSDC')
#ws_client.trade_stream(h3,'BTCUSDC')
#ws_client.klines_stream(h4,'BTCUSDC',1)
ws_client.account_info_stream(handle_account)

while True:
    # Run your main trading logic here.
    sleep(1)

```


## Old Basic Usage V1
You can create an HTTP session for Inverse on APEX_HTTP_TEST or APEX_HTTP_MAIN:

```python
from apexomni.constants import APEX_HTTP_TEST
from apexomni.http_public import HttpPublic

client = HttpPublic(APEX_HTTP_TEST)
```
### Public endpoints
You can get no authentication information from public endpoints.  
Please refer to [demo_public](https://github.com/ApeX-Protocol/apexpro-openapi/blob/main/tests/demo_public.py)

```python
from apexomni.constants import APEX_HTTP_TEST
from apexomni.http_public import HttpPublic

client = HttpPublic(APEX_HTTP_TEST)
print(client.server_time())
print(client.configs())
print(client.ticker(symbol="BTC-USDC"))
print(client.history_funding(symbol="BTC-USDC"))
print(client.depth(symbol="ETH-USDC", limit=100))
print(client.trades(symbol="ETH-USDC", limit=100))
print(client.klines(symbol="ETH-USDC", interval="15"))
print(client.history_funding(symbol="ETH-USDC", limit=100, page=0, beginTimeInclusive=1662348573000,
                             endTimeExclusive=1662434973000))
```

### Register  method
You can get stark_key_pair, apiKey,and accountId for private Api , create-order and withdraw  
Please refer to [demo_register](https://github.com/ApeX-Protocol/apexpro-openapi/blob/main/tests/demo_register.py)

```python
from apexomni.http_private import HttpPrivate
from apexomni.constants import APEX_HTTP_TEST, NETWORKID_TEST, APEX_HTTP_MAIN, NETWORKID_MAIN

priKey = "your eth private key"

client = HttpPrivate(APEX_HTTP_TEST, network_id=NETWORKID_TEST, eth_private_key=priKey)
configs = client.configs()

stark_key_pair_with_y_coordinate = client.derive_stark_key(client.default_address)
nonceRes = client.generate_nonce(starkKey=stark_key_pair_with_y_coordinate['public_key'],
                                 ethAddress=client.default_address, chainId=NETWORKID_TEST)

regRes = client.register_user(nonce=nonceRes['data']['nonce'], starkKey=stark_key_pair_with_y_coordinate['public_key'],
                              stark_public_key_y_coordinate=stark_key_pair_with_y_coordinate['public_key_y_coordinate'],
                              ethereum_address=client.default_address)
key = regRes['data']['apiKey']['key']
secret = regRes['data']['apiKey']['secret']
passphrase = regRes['data']['apiKey']['passphrase']

#back stark_key_pair, apiKey,and accountId for private Api or create-order or withdraw
print(stark_key_pair_with_y_coordinate)
print(regRes['data']['account']['positionId'])
print(regRes['data']['apiKey'])
```

### Private endpoints
some authentication information is required to access private endpoints. 
Please refer to [demo_private](https://github.com/ApeX-Protocol/apexpro-openapi/blob/main/tests/demo_private.py)

```python
from apexomni.http_private import HttpPrivate
from apexomni.constants import APEX_HTTP_TEST, NETWORKID_TEST

# need apiKey={'key': key,'secret': secret, 'passphrase': passphrase} for private api

key = 'your apiKey-key from register'
secret = 'your apiKey-secret from register'
passphrase = 'your apiKey-passphrase from register'

client = HttpPrivate(APEX_HTTP_TEST, network_id=NETWORKID_TEST,
                     api_key_credentials={'key': key, 'secret': secret, 'passphrase': passphrase})
configs = client.configs()

userRes = client.get_user()
print(userRes)

modifyUserRes = client.modify_user(username="pythonTest", email="11@aa.com", emailNotifyGeneralEnable="false")
print(modifyUserRes)

accountRes = client.get_account()
print(accountRes)

openOrdersRes = client.open_orders()
print(openOrdersRes)

historyOrdersRes = client.history_orders()
print(historyOrdersRes)

fundingRes = client.funding(limit=100, page=0, symbol="BTC-USDC", side="BUY")
print(fundingRes)

notifyListRes = client.notify_list(limit=100, page=0, unreadOnly="true", notifyCategory="1")
print(notifyListRes)

...
```

### Stark key sign method
Several endpoints require a starkKey signature authentication, namely as following:
- create-order
- withdraw

Please refer to [demo_stark_key_sign](https://github.com/ApeX-Protocol/apexpro-openapi/blob/main/tests/demo_stark_key_sign.py)

```python
import time
from apexomni.http_private_stark_key_sign import HttpPrivateStark

from apexomni.constants import APEX_HTTP_TEST, NETWORKID_TEST

# need api_key_credentials={'key': key,'secret': secret, 'passphrase': passphrase} for private api
# need starkey for withdraw and createOrder

key = 'your apiKey-key from register'
secret = 'your apiKey-secret from register'
passphrase = 'your apiKey-passphrase from register'

public_key = 'your stark_public_key from register'
public_key_y_coordinate = 'your stark_public_key_y_coordinate from register'
private_key = 'your stark_private_key from register'

client = HttpPrivateStark(APEX_HTTP_TEST, network_id=NETWORKID_TEST,
                          stark_public_key=public_key,
                          stark_private_key=private_key,
                          stark_public_key_y_coordinate=public_key_y_coordinate,
                          api_key_credentials={'key': key, 'secret': secret, 'passphrase': passphrase})
configs = client.configs()
client.get_user()
client.get_account()

currentTime = time.time()

limitFeeRate = client.account['takerFeeRate']
createOrderRes = client.create_order(symbol="BTC-USDC", side="BUY",
                                     type="LIMIT", size="0.01",
                                     price="1991", limitFeeRate=limitFeeRate,
                                     accountId=client.account['positionId'],
                                     expirationEpochSeconds=currentTime)
print(createOrderRes)

worstPrice = client.get_worst_price(symbol="BTC-USDC", side="SELL", size="0.1")
price = worstPrice['data']['worstPrice']
##market order price must not none
createOrderRes = client.create_order(symbol="BTC-USDC", side="SELL",
                                     type="MARKET", size="1", price=price, limitFee=limitFee,
                                     expirationEpochSeconds=currentTime)
print(createOrderRes)

#createWithdrawRes = client.create_withdrawal(amount='1001',expirationEpochSeconds= currentTime,asset='USDC')
#print(createWithdrawRes)

#feeRes = client.uncommon_withdraw_fee(amount='1002',chainId='5')
#print(feeRes)
#fastWithdrawRes = client.fast_withdrawal(amount='1002',expirationEpochSeconds= currentTime,asset='USDC',fee=feeRes['data']['fee'])
#print(fastWithdrawRes)

deleteOrderRes = client.delete_open_orders(symbol="BTC-USDC")
print(deleteOrderRes)

deleteOrderRes = client.delete_open_orders()
print(deleteOrderRes)

feeRes = client.uncommon_withdraw_fee(amount='1003', chainId='97')
print(feeRes)
crossWithdrawRes = client.cross_chain_withdraw(amount='1003', expirationEpochSeconds=currentTime, asset='USDC',
                                               fee=feeRes['data']['fee'], chainId='97')
print(crossWithdrawRes)

```

### WebSocket
To see comprehensive examples of how to subscribe topics from websockets.
Please refer to [demo_ws](https://github.com/ApeX-Protocol/apexpro-openapi/blob/main/tests/demo_ws.py)

```python
from time import sleep

from apexomni.constants import APEX_WS_TEST
from apexomni.websocket_api import WebSocket

key = 'your apiKey-key from register'
secret = 'your apiKey-secret from register'
passphrase = 'your apiKey-passphrase from register'

# Connect with authentication!
ws_client = WebSocket(
    endpoint=APEX_WS_TEST,
    api_key_credentials={'key': key, 'secret': secret, 'passphrase': passphrase},
)


def handle_account(message):
    print(message)
    contents_data = message["contents"]
    print(len(contents_data))


def h1(message):
    print(1, message)


def h2(message):
    print(2, message)


def h3(message):
    print(3, message)


def h4(message):
    print(4, message)


#ws_client.depth_stream(h1,'BTCUSDC',25)
#ws_client.ticker_stream(h2,'BTCUSDC')
#ws_client.trade_stream(h3,'BTCUSDC')
#ws_client.klines_stream(h4,'BTCUSDC',1)
ws_client.account_info_stream(handle_account)

while True:
    # Run your main trading logic here.
    sleep(1)

```



================================================
FILE: README_V3.md
================================================
# apex omni

Official Python3 API connector for Apex omni's HTTP and WebSockets APIs.  
You can get Api information from 
[OpenApi-SDK](https://api-docs.pro.apex.exchange/#introduction)

## About
Put simply, `apex omni` is the official lightweight one-stop-shop module for the Apex omni HTTP and WebSocket APIs. 

## Development
- `apex omni` is being actively developed, and new API changes should arrive on `apex omni` very quickly. `apex omni` uses `requests` and `websocket` for its methods, alongside other built-in modules. Anyone is welcome to branch/fork the repository and add their own upgrades. If you think you've made substantial improvements to the module, submit a pull request and we'll gladly take a look.      

## Installation
`apex omni` supports Python versions from 3.6 to 3.12. The module can be installed manually or via [apexomni](https://pypi.org/project/apexomni/)   with `pip`:
```
pip3 install apexomni
```
## New Basic Usage V3 
You can create an HTTP session for Inverse on APEX_OMNI_HTTP_TEST or APEX_OMNI_HTTP_MAIN:

```python
from apexomni.constants import APEX_OMNI_HTTP_TEST
from apexomni.http_public import HttpPublic

client = HttpPublic(APEX_OMNI_HTTP_TEST)
```
### Public endpoints V3

You can get no authentication information from public endpoints.  
Please refer to [demo_public_v3](https://github.com/ApeX-Protocol/apexpro-openapi/blob/main/tests/demo_public_v3.py)

The V3 version supports  USDT symbols. Users need to request the configs_v3() interface to obtain the configuration of symbols.
```python
client = HttpPublic(APEX_OMNI_HTTP_MAIN)
print(client.configs_v3())
print(client.klines_v3(symbol="ETHUSDT",interval=5,start=1718358480, end=1718950620, limit=5))
print(client.depth_v3(symbol="BTCUSDT"))
print(client.trades_v3(symbol="BTCUSDT"))
print(client.klines_v3(symbol="BTCUSDT",interval="15"))
print(client.ticker_v3(symbol="BTCUSDT"))
print(client.history_funding_v3(symbol="BTC-USDT"))
```

### Register OMNI method V3
- You can get zkKeys from client.derive_zk_key(), for regiter-user, create-order or transfer and withdraw.    
- If the user wants to trade OMNI's symbols, needs to call the register_user_v3() interface to register a OMNI account.   
- If the user has previously registered a pro apex account using the v1 or v2 interface, you also need to use the register_user_v3()   
    interface to register again.        
- You need to call client.configs_v3() after init client.      
- You can get apiKey and accountId for private Api    
- After call register_user_v3(), the user must call change_pub_key_v3() to complete register v3 account.   
- Since the register_user_v3  is a non-blocking process, you need to sleep for 10 sec before call the change_pub_key_v3() action.
Please refer to [demo_register_v3](https://github.com/ApeX-Protocol/apexpro-openapi/blob/main/tests/demo_register_v3.py)

```python
from apexomni.constants import APEX_OMNI_HTTP_MAIN, NETWORKID_OMNI_MAIN_ARB, NETWORKID_MAIN

print("Hello, Apex Omni")
priKey = "your eth private key"

client = HttpPrivate_v3(APEX_OMNI_HTTP_MAIN, network_id=NETWORKID_MAIN, eth_private_key=priKey)
configs = client.configs_v3()

zkKeys = client.derive_zk_key(client.default_address)
print(zkKeys)

nonceRes = client.generate_nonce_v3(refresh="false", l2Key=zkKeys['l2Key'], ethAddress=client.default_address,
                                    chainId=NETWORKID_OMNI_MAIN_ARB)

regRes = client.register_user_v3(nonce=nonceRes['data']['nonce'], l2Key=zkKeys['l2Key'], seeds=zkKeys['seeds'],
                                 ethereum_address=client.default_address)

key = regRes['data']['apiKey']['key']
secret = regRes['data']['apiKey']['secret']
passphrase = regRes['data']['apiKey']['passphrase']

time.sleep(10)
accountRes = client.get_account_v3()
print(accountRes)

# back zkKeys, apiKey,and accountId for private Api or create-oreder transfer or withdraw

print(regRes['data']['account']['id'])
print(regRes['data']['apiKey'])

changeRes = client.change_pub_key_v3(chainId=NETWORKID_OMNI_MAIN_ARB, seeds=zkKeys.get('seeds'), ethPrivateKey=priKey,
                                     zkAccountId=accountRes.get('spotAccount').get('zkAccountId'),
                                     subAccountId=accountRes.get('spotAccount').get('defaultSubAccountId'),
                                     newPkHash=zkKeys.get('pubKeyHash'),
                                     nonce=accountRes.get('spotAccount').get('nonce'), l2Key=zkKeys.get('l2Key'))
print(changeRes)

time.sleep(10)
accountRes = client.get_account_v3()
print(accountRes)
```

### Private endpoints V3
Users need to request the configs_v3() and get_account_v3() interface to obtain the configuration of Account.   

some authentication information is required to access private endpoints.   
Please refer to [demo_private_v3](https://github.com/ApeX-Protocol/apexpro-openapi/blob/main/tests/demo_private_v3.py)

```python
from apexomni.constants import APEX_OMNI_HTTP_MAIN,
    NETWORKID_OMNI_MAIN_ARB

print("Hello, Apex Omni")
# need api_key_credentials={'key': key,'secret': secret, 'passphrase': passphrase} for private api

key = 'your apiKey-key from register V3'
secret = 'your apiKey-secret from register  V3'
passphrase = 'your apiKey-passphrase from register  V3'

client = HttpPrivate_v3(APEX_OMNI_HTTP_MAIN, network_id=NETWORKID_OMNI_MAIN_ARB,
                        api_key_credentials={'key': key, 'secret': secret, 'passphrase': passphrase})
configs = client.configs_v3()

userRes = client.get_user_v3()
print(userRes)

accountRes = client.get_account_v3()
print(accountRes)

accountBalanceRes = client.get_account_balance_v3()
print(accountBalanceRes)

fillsRes = client.fills_v3(limit=100, page=0, symbol="BTC-USDT", side="BUY", token="USDT")
print(fillsRes)

transfersRes = client.transfers_v3(limit=100)
print(transfersRes)

transferRes = client.transfer_v3(ids='586213648326721628')
print(transferRes)

transfersRes = client.contract_transfers_v3(limit=100)
print(transfersRes)

transferRes = client.contract_transfer_v3(ids='588301879870489180')
print(transferRes)

# deleteOrderRes = client.delete_order_v3(id="588302655921587036")
# print(deleteOrderRes)

# deleteOrderRes = client.delete_order_by_client_order_id_v3(id="123456")
# print(deleteOrderRes)

openOrdersRes = client.open_orders_v3()
print(openOrdersRes)

deleteOrdersRes = client.delete_open_orders_v3(symbol="BTC-USDT", )
print(deleteOrdersRes)

historyOrdersRes = client.history_orders_v3(token='USDT')
print(historyOrdersRes)

getOrderRes = client.get_order_v3(id="123456")
print(getOrderRes)

getOrderRes = client.get_order_by_client_order_id_v3(id="123456")
print(getOrderRes)

fundingRes = client.funding_v3(limit=100)
print(fundingRes)

historicalPnlRes = client.historical_pnl_v3(limit=100)
print(historicalPnlRes)

yesterdayPnlRes = client.yesterday_pnl_v3()
print(yesterdayPnlRes)

historyValueRes = client.history_value_v3()
print(historyValueRes)

setInitialMarginRateRes = client.set_initial_margin_rate_v3(symbol="BTC-USDT", initialMarginRate="0.05")
print(setInitialMarginRateRes)

```

### zkKey sign withdraw or transfer method
Users need to request the configs_v3() and get_account_v3() interface to obtain the configuration of Account.    

Several endpoints require a seeds and l2Key signature authentication, namely as following:    
- create_withdrawal_v3()  to withdraw or fast withdraw
- create_transfer_out_v3()   to transfer asset from spot account to contract account   
- create_contract_transfer_out_v3()   to transfer asset from contract account to spot account    

Please refer to [demo_transfer_v3](https://github.com/ApeX-Protocol/apexpro-openapi/blob/main/tests/demo_transfer_v3.py)

```python
key = 'your apiKey-key from register'
secret = 'your apiKey-secret from register'
passphrase = 'your apiKey-passphrase from register'

seeds = 'your zk seeds from register'
l2Key = 'your l2Key seeds from register'

client = HttpPrivateSign(APEX_OMNI_HTTP_TEST, network_id=NETWORKID_TEST,
                          zk_seeds=seeds,zk_l2Key=l2Key,
                          api_key_credentials={'key': key, 'secret': secret, 'passphrase': passphrase})
configs = client.configs_v3()
accountData = client.get_account_v3()

#smple1 withdraw
#createWithdrawRes = client.create_withdrawal_v3(amount='3',asset='USDT', toChainId=3)
#print(createWithdrawRes)

#smple2 fast withdraw
#withdraw_feeRes = client.withdraw_fee_v3(amount="3",chainIds="3",tokenId='140')
#print(withdraw_feeRes)
#createWithdrawRes = client.create_withdrawal_v3(amount='3',asset='USDT', toChainId=3, fee=withdraw_feeRes.get('data').get('withdrawFeeAndPoolBalances')[0].get('fee'), isFastWithdraw=True)
#print(createWithdrawRes)

#smple3 transfer_out
#createTransferRes = client.create_transfer_out_v3(amount='3.4359738368',asset='USDT')
#print(createTransferRes)

#smple4 contract transfer_out
createContractTransferRes = client.create_contract_transfer_out_v3(amount='3.4359738368',asset='USDT')
print(createContractTransferRes)

```


### zkKey sign create order method
Users need to request the configs_v3() and get_account_v3() interface to obtain the configuration of Account.    
Several endpoints require a seeds and l2Key signature authentication, namely as following:    
- create_order_v3()  to create order

```python
from apexomni.constants import NETWORKID_TEST, APEX_OMNI_HTTP_TEST

print("Hello, Apex omni")

key = 'your apiKey-key from register'
secret = 'your apiKey-secret from register'
passphrase = 'your apiKey-passphrase from register'

seeds = 'your zk seeds from register'
l2Key = 'your l2Key seeds from register'

client = HttpPrivateSign(APEX_OMNI_HTTP_TEST, network_id=NETWORKID_TEST,
                         zk_seeds=seeds, zk_l2Key=l2Key,
                         api_key_credentials={'key': key, 'secret': secret, 'passphrase': passphrase})
configs = client.configs_v3()
accountData = client.get_account_v3()

currentTime = time.time()
createOrderRes = client.create_order_v3(symbol="BTC-USDT", side="SELL",
                                        type="MARKET", size="0.001", timestampSeconds=currentTime,
                                        price="60000")
print(createOrderRes)

# sample6
# Create a  TP/SL order
# first, Set a slippage to get an acceptable slPrice or tpPrice
#slippage is recommended to be greater than 0.1
# when buying, the price = price*(1 + slippage). when selling, the price = price*(1 - slippage)
slippage = decimal.Decimal("-0.1")
slPrice = decimal.Decimal("58000") * (decimal.Decimal("1") + slippage)
tpPrice = decimal.Decimal("79000") * (decimal.Decimal("1") - slippage)

createOrderRes = client.create_order_v3(symbol="BTC-USDT", side="BUY",
                                        type="LIMIT", size="0.01",
                                        price="65000",
                                        isOpenTpslOrder=True,
                                        isSetOpenSl=True,
                                        slPrice=slPrice,
                                        slSide="SELL",
                                        slSize="0.01",
                                        slTriggerPrice="58000",
                                        isSetOpenTp=True,
                                        tpPrice=tpPrice,
                                        tpSide="SELL",
                                        tpSize="0.01",
                                        tpTriggerPrice="79000",
                                        )
print(createOrderRes)

print("end, apexomni")

```

### WebSocket
To see comprehensive examples of how to subscribe topics from websockets.
Please refer to [demo_ws_v3](https://github.com/ApeX-Protocol/apexpro-openapi/blob/main/tests/demo_ws_v3.py)


```python
from time import sleep

from apexomni.constants import APEX_OMNI_WS_MAIN
from apexomni.websocket_api import WebSocket

key = 'your apiKey-key from register V3'
secret = 'your apiKey-secret from register  V3'
passphrase = 'your apiKey-passphrase from register  V3'


# Connect with authentication!
# APEX_OMNI_WS_MAIN for mainnet, APEX_OMNI_WS_TEST for testnet
ws_client = WebSocket(
    endpoint=APEX_OMNI_WS_MAIN,
    api_key_credentials={'key': key, 'secret': secret, 'passphrase': passphrase},
)

def handle_account(message):
    print(message)
    contents_data = message["contents"]
    print(len(contents_data))

def h1(message):
    print(1, message)
def h2(message):
    print(2, message)
def h3(message):
    print(3, message)
def h4(message):
    print(4, message)

#ws_client.depth_stream(h1,'BTCUSDT',25)
#ws_client.ticker_stream(h2,'BTCUSDT')
ws_client.trade_stream(h3,'BTCUSDT')
ws_client.klines_stream(h4,'BTCUSDT',1)
ws_client.account_info_stream_v3(handle_account)


while True:
    # Run your main trading logic here.
    sleep(1)




================================================
FILE: setup.cfg
================================================
[metadata]
license_files = LICENSE

[options]
zip_safe = False

[bdist_wheel]
universal = 1

[egg_info]
tag_build = 
tag_date = 0




================================================
FILE: setup.py
================================================
from setuptools import setup, find_packages
from os import path

here = path.abspath(path.dirname(__file__))

with open(path.join(here, 'README.md'), encoding='utf-8') as f:
    long_description = f.read()



setup(
    name='apexomni-x86-mac',
    version='3.1.0',
    packages=find_packages(),
    description='Python3 Apexpro omni HTTP/WebSocket API Connector',
    long_description=long_description,
    long_description_content_type='text/markdown',
    url='https://github.com/ApeX-Protocol/apexpro-openapi',
    license='MIT License',
    author='Dexter Dickinson',
    author_email='xxx@apexomni.com',
    classifiers=[
        'Development Status :: 4 - Beta',
        'Intended Audience :: Developers',
        'Topic :: Software Development :: Libraries :: Python Modules',
        'License :: OSI Approved :: MIT License',
        'Programming Language :: Python :: 3.6',
        'Programming Language :: Python :: 3.7',
        'Programming Language :: Python :: 3.8',
        'Programming Language :: Python :: 3.9',
        'Programming Language :: Python :: 3.10',
        'Programming Language :: Python :: 3.11',
        'Programming Language :: Python :: 3.12',
    ],
    keywords='apexomni apexpro api connector',
    package_data={'': ['*.json','*.dylib','*.dll','*.so']},
    data_files=[('apexpro', ['apexpro/starkex/starkex_resources/pedersen_params.json', 'apexpro/libzklink_sdk.dylib'])],
    # packages=['apexpro'],
    python_requires='>=3.6',
    install_requires=[
        'requests',
        'websocket-client',
        'websockets',
        'dateparser==1.0.0',
        'ecdsa==0.16.0',
        'eth_keys',
        'eth-account==0.13.7',
        'mpmath==1.0.0',
        'pytest>=4.4.0,<5.0.0',
        'requests-mock==1.6.0',
        'requests>=2.32.3,<3.0.0',
        'setuptools>=50.3.2',
        'sympy==1.6',
        'tox==3.13.2',
        'web3==6.0.0',
    ],
)



================================================
FILE: tox.ini
================================================
[tox]
envlist = py{36,37,38,39,310,311,312}
skipsdist = True
skip_missing_interpreters = False
ignore_basepython_conflict = True

[testenv]
basepython = python3
sitepackages = True
setenv =
    PYTHONPATH = {toxinidir}:{toxinidir}
deps =
    pip
    setuptools
    wheel
    aiohttp
    cryptography
    requests
commands =
    pytest



================================================
FILE: apexomni/__init__.py
================================================
# -*- coding: utf-8 -*-

"""
apexpro
------------------------

apexpro is a lightweight and high-performance API connector for the
RESTful and WebSocket APIs of the Apex pro exchange.

Documentation can be found at
https://api-docs.pro.apex.exchange/#introduction

:copyright: (c) 2020-2022 apexpro-exchange
:license: MIT License

"""

import time
import hmac
import json
import logging
import requests
import platform
import sys
import os
from pathlib import Path

from web3 import Web3
from apexomni.eth_signing import SignWithWeb3, SignOnboardingAction
from apexomni.eth_signing import SignWithKey
from apexomni.constants import REGISTER_ENVID_MAIN, APEX_HTTP_MAIN, URL_SUFFIX, NETWORKID_MAIN
from apexomni.starkex.helpers import private_key_to_public_key_pair_hex

from datetime import datetime as dt
from concurrent.futures import ThreadPoolExecutor

from .eth import Eth
from .exceptions import FailedRequestError, InvalidRequestError
from .models import configDecoder

try:
    from simplejson.errors import JSONDecodeError
except ImportError:
    from json.decoder import JSONDecodeError

# Versioning.
VERSION = '1.0.0'


class HTTP:
    """
    Connector for Apexpro's HTTP API.

    The below class is maintained for compatibility reasons. You should
    prefer using the market-specific classes maintained in
    inverse_perpetual.py, usdc_perpetual.py, spot.py, etc

    :param endpoint: The endpoint URL of the HTTP API, e.g.
        'https://dev.pro.apex.exchange.com'.
    :type endpoint: str

    """

    # def __init__(self, endpoint=None, api_key=None, api_secret=None,
    #             logging_level=logging.INFO, log_requests=False,
    #             request_timeout=10, recv_window=5000, force_retry=False,
    #             retry_codes=None, ignore_codes=None, max_retries=3,
    #             retry_delay=3, referral_id=None, spot=False):
    #    """Initializes the HTTP class."""

    def __init__(
            self,
            endpoint,
            api_timeout=3000,  # TODO: Actually use this.
            default_ethereum_address=None,
            eth_private_key=None,
            eth_send_options=None,
            network_id=NETWORKID_MAIN,
            env_id=REGISTER_ENVID_MAIN,
            stark_private_key=None,
            stark_public_key=None,
            stark_public_key_y_coordinate=None,
            zk_seeds=None,
            zk_l2Key=None,
            web3=None,
            web3_account=None,
            web3_provider=None,
            api_key_credentials=None,
            request_timeout=10, recv_window=5000, force_retry=False,
            retry_codes=None, max_retries=3,
            retry_delay=3, referral_id=None, proxies=None
    ):
        # Remove trailing '/' if present, from host.
        if endpoint.endswith('/'):
            self.endpoint = endpoint[:-1]
        # Set the endpoint.
        if endpoint is None:
            self.endpoint = APEX_HTTP_MAIN
        else:
            self.endpoint = endpoint

        # Setup logger.

        self.logger = logging.getLogger(__name__)

        if len(logging.root.handlers) == 0:
            # no handler on root logger set -> we add handler just for this logger to not mess with custom logic from outside
            handler = logging.StreamHandler()
            handler.setFormatter(logging.Formatter(fmt='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
                                                   datefmt='%Y-%m-%d %H:%M:%S'
                                                   )
                                 )
            handler.setLevel(logging.INFO)
            self.logger.addHandler(handler)

        #self.logger.warning(
        #    'This HTTP class is maintained for compatibility purposes. You '
        #    'should prefer importing market-specific classes, like so: '
        #    'from apexpro import HTTP; '
        #)

        self.logger.debug('Initializing HTTP session.')
        self.log_requests = False

        self.proxies = proxies
        # Set web3 keys.
        self.eth_send_options = eth_send_options or {}
        self.stark_private_key = stark_private_key
        self.api_key_credentials = api_key_credentials
        self.stark_public_key_y_coordinate = stark_public_key_y_coordinate
        self.zk_seeds = zk_seeds
        self.zk_l2Key = zk_l2Key
        self.web3 = None
        self._eth = None
        self.eth_signer = None
        self.default_address = None
        self.network_id = None

        if web3 is not None or web3_provider is not None:
            if isinstance(web3_provider, str):
                web3_provider = Web3.HTTPProvider(web3_provider)
            self.web3 = web3 or Web3(web3_provider)
            self.eth_signer = SignWithWeb3(self.web3)
            self.default_address = self.web3.eth.defaultAccount or None
            self.network_id = self.web3.net.version

        if eth_private_key is not None or web3_account is not None:
            # May override web3 or web3_provider configuration.
            key = eth_private_key or web3_account.key
            self.eth_signer = SignWithKey(key)
            self.default_address = self.eth_signer.address

        self.default_address = default_ethereum_address or self.default_address
        self.network_id = int(
            network_id or self.network_id or REGISTER_ENVID_MAIN
        )
        self.env_id = int(
            env_id or self.env_id or REGISTER_ENVID_MAIN
        )

        # Derive the public keys.
        if stark_private_key is not None:
            self.stark_public_key, self.stark_public_key_y_coordinate = (
                private_key_to_public_key_pair_hex(stark_private_key)
            )
        if (
                stark_public_key is not None and
                stark_public_key != self.stark_public_key
        ):
            self.logger.warning('STARK public/private key mismatch')
        if (
                stark_public_key_y_coordinate is not None and
                stark_public_key_y_coordinate !=
                self.stark_public_key_y_coordinate
        ):
            self.logger.warning('STARK public/private key mismatch (y)')
        else:
            self.stark_public_key = stark_public_key
            self.stark_public_key_y_coordinate = stark_public_key_y_coordinate

        self.api_key_credentials = api_key_credentials

        self.signer = SignOnboardingAction(self.eth_signer, self.network_id)
        self.starkeySigner = SignOnboardingAction(self.eth_signer, self.env_id)

        # Set timeout.
        self.timeout = request_timeout
        self.recv_window = recv_window
        self.force_retry = force_retry
        self.max_retries = max_retries
        self.retry_delay = retry_delay

        # Set whitelist of non-fatal Apexpro status codes to retry on.
        if retry_codes is None:
            self.retry_codes = {10002, 10006, 30034, 30035, 130035, 130150}
        else:
            self.retry_codes = retry_codes

        # Initialize requests session.
        self.client = requests.Session()
        #self.client.trust_env = False
        self.client.headers.update(
            {
                'User-Agent': 'apexpro-python-sdk-' + VERSION,
                'Accept': 'application/json',
                'Content-Type': 'application/x-www-form-urlencoded'
            }
        )
        self.client.proxies = self.proxies

        # Add referral ID to header.
        if referral_id:
            self.client.headers.update({'Referer': referral_id})

    def _exit(self):
        """Closes the request session."""
        self.client.close()
        self.logger.debug('HTTP session closed.')

    def _auth(self, method, params, recv_window):
        """
        Generates authentication signature per Apexpro API specifications.

        Notes
        -------------------
        Since the POST method requires a JSONified dict, we need to ensure
        the signature uses lowercase booleans instead of Python's
        capitalized booleans. This is done in the bug fix below.

        """

        api_key = self.api_key
        api_secret = self.api_secret

        if api_key is None or api_secret is None:
            raise PermissionError('Authenticated endpoints require keys.')

        # Append required parameters.
        params['api_key'] = api_key
        params['recv_window'] = recv_window
        params['timestamp'] = int(time.time() * 10 ** 3)

        # Sort dictionary alphabetically to create querystring.
        _val = '&'.join(
            [str(k) + '=' + str(v) for k, v in sorted(params.items()) if
             (k != 'sign') and (v is not None)]
        )

        # Bug fix. Replaces all capitalized booleans with lowercase.
        if method == 'POST':
            _val = _val.replace('True', 'true').replace('False', 'false')

        # Return signature.
        return str(hmac.new(
            bytes(api_secret, 'utf-8'),
            bytes(_val, 'utf-8'), digestmod='sha256'
        ).hexdigest())

    @property
    def eth(self):
        '''
        Get the eth module, used for interacting with Ethereum smart contracts.
        '''
        collateral_asset_id = ''
        token_contracts = ''
        web3_provider = ''
        starware_perpetuals_contract = self.config.get('global').get('starkExContractAddress')
        for k, v1 in enumerate(self.config.get('currency')):
            if v1.get('id') == 'USDC':
                collateral_asset_id = v1.get('starkExAssetId')
        for k, v2 in enumerate(self.config.get('multiChain').get('chains')):
            if v2.get('chainId') == self.network_id:
                web3_provider = v2.get('rpcUrl')
                for k, v3 in enumerate(v2.get('tokens')):
                    if v3.get('token') == 'USDC':
                        token_contracts = v3.get('tokenAddress')

        web3_provider = Web3.HTTPProvider(web3_provider)
        self.web3 =  Web3(web3_provider)

        if not self._eth:
            eth_private_key = getattr(self.eth_signer, '_private_key', None)
            if self.web3 and eth_private_key:
                self._eth = Eth(
                    web3=self.web3,
                    network_id=self.network_id,
                    eth_private_key=eth_private_key,
                    default_address=self.default_address,
                    stark_public_key=self.stark_public_key,
                    send_options=self.eth_send_options,
                    collateral_asset_id = collateral_asset_id,
                    starware_perpetuals_contract = starware_perpetuals_contract,
                    token_contracts = token_contracts,
                )
            else:
                raise Exception(
                    'Eth module is not supported since neither web3 ' +
                    'nor web3_provider was provided OR since neither ' +
                    'eth_private_key nor web3_account was provided',
                    )
        return self._eth

    def _verify_string(self, params, key):
        if key in params:
            if not isinstance(params[key], str):
                return False
            else:
                return True
        return True

    def configs(self, **kwargs):
        suffix = URL_SUFFIX + "/v1/symbols"
        configs = self._submit_request(
            method='GET',
            path=self.endpoint + suffix
        )
        self.env_id = configs['data']['global']['registerEnvId']
        self.config = configs['data']
        self.starkeySigner = SignOnboardingAction(self.eth_signer, self.env_id)
        return configs

    def configs_v2(self, **kwargs):
        suffix = URL_SUFFIX + "/v2/symbols"
        configs = self._submit_request(
            method='GET',
            path=self.endpoint + suffix
        )
        self.configV2 = configs['data']
        self.env_id = configs['data']['usdcConfig']['global']['registerEnvId']
        self.usdcConfigV2 = configs['data']['usdcConfig']
        self.usdtConfigV2 = configs['data']['usdtConfig']
        self.starkeySigner = SignOnboardingAction(self.eth_signer, self.env_id)
        return configs

    def configs_v3(self, **kwargs):
        suffix = URL_SUFFIX + "/v3/symbols"
        configs = self._submit_request(
            method='GET',
            path=self.endpoint + suffix
        )
        self.configV3 = configs['data']
        return configs

    def _submit_request(self, method=None, path=None, query=None, headers=None):
        """
        Submits the request to the API.

        Notes
        -------------------
        We use the params argument for the GET method, and data argument for
        the POST method. Dicts passed to the data argument must be
        JSONified prior to submitting request.

        """

        if query is None:
            query = {}

        # Store original recv_window.
        recv_window = self.recv_window

        # Send request and return headers with body. Retry if failed.
        retries_attempted = self.max_retries
        req_params = None

        while True:

            retries_attempted -= 1
            if retries_attempted < 0:
                raise FailedRequestError(
                    request=f'{method} {path}: {req_params}',
                    message='Bad Request. Retries exceeded maximum.',
                    status_code=400,
                    time=dt.utcnow().strftime("%H:%M:%S")
                )

            retries_remaining = f'{retries_attempted} retries remain.'

            # Define parameters and log the request.
            if query is not None:
                req_params = {k: v for k, v in query.items() if
                              v is not None}

            else:
                req_params = {}

            # Log the request.
            if self.log_requests:
                self.logger.debug(f'Request -> {method} {path}: {req_params}')

            # Prepare request; use 'params' for GET and 'data' for POST.
            if method == 'GET':
                r = self.client.prepare_request(
                    requests.Request(method, path, params=req_params,
                                     headers=headers)
                )
            elif method == 'POST':
                r = self.client.prepare_request(
                    requests.Request(method, path,
                                     data=req_params,
                                     headers=headers)
                )

            # Attempt the request.
            try:
                s = self.client.send(r, timeout=self.timeout)

            # If requests fires an error, retry.
            except (
                    requests.exceptions.ReadTimeout,
                    requests.exceptions.SSLError,
                    requests.exceptions.ConnectionError
            ) as e:
                if self.force_retry:
                    self.logger.error(f'{e}. {retries_remaining}')
                    time.sleep(self.retry_delay)
                    continue
                else:
                    raise e

            # Convert response to dictionary, or raise if requests error.
            try:
                s_json = s.json()

            # If we have trouble converting, handle the error and retry.
            except JSONDecodeError as e:
                if self.force_retry:
                    self.logger.error(f'{e}. {retries_remaining}')
                    time.sleep(self.retry_delay)
                    continue
                else:
                    raise FailedRequestError(
                        request=f'{method} {path}: {req_params}',
                        message='Conflict. Could not decode JSON: ' + s.text,
                        status_code=409,
                        time=dt.utcnow().strftime("%H:%M:%S")
                    )
            else:
                return s_json

def get_os_specific_module():
    """"""
    system = platform.system().lower()
    machine = platform.machine().lower()
    if system == 'darwin':
        if machine == 'x86_64':
            from apexomni.x86 import zklink_sdk as os_specific
        elif machine == 'arm64':
            from apexomni.arm import zklink_sdk as os_specific
    elif system == 'linux':
        if machine == 'x86_64':
            from apexomni.pc.linux_x86 import zklink_sdk as os_specific
        elif machine == 'arm64':
            from apexomni.pc.linux_arm import zklink_sdk as os_specific
    elif system == 'windows':
        from apexomni.pc import zklink_sdk as os_specific
    else:
        raise RuntimeError(f"Unsupported system: {system}")

    return os_specific

# 
zklink_sdk = get_os_specific_module()
__all__ = ['zklink_sdk']



================================================
FILE: apexomni/_websocket_stream.py
================================================
import base64
import hashlib

import websocket
import threading
import time
import json
import hmac
import logging
import re
import copy
from . import HTTP, APEX_HTTP_MAIN
from .constants import APEX_WS_MAIN
from .helpers.request_helpers import generate_now


logger = logging.getLogger(__name__)

PRIVATE_REQUEST_PATH = '/ws/accounts'
PRIVATE_WSS = "/realtime_private?v=2"
PUBLIC_WSS = "/realtime_public?v=2"

class _WebSocketManager:
    def __init__(self, callback_function, endpoint="", api_key_credentials=None,
                 ping_interval=15, ping_timeout=None,
                 restart_on_error=True, trace_logging=False):

        if endpoint.endswith('/'):
            self.endpoint = endpoint[:-1]
        # Set the endpoint.
        if endpoint is None:
            self.endpoint = APEX_WS_MAIN
        else:
            self.endpoint = endpoint

        self.api_key_credentials = api_key_credentials

        self.callback = callback_function

        # Setup the callback directory following the format:
        #   {
        #       "topic_name": function
        #   }
        self.callback_directory = {}

        # Set ping settings.
        self.ping_interval = ping_interval
        self.ping_timeout = ping_timeout

        # Other optional data handling settings.
        self.handle_error = restart_on_error
        self.timer = None
        self.r_timer = None

        # Enable websocket-client's trace logging for extra debug information
        # on the websocket connection, including the raw sent & recv messages
        websocket.enableTrace(trace_logging)

        # Set initial state, initialize dictionary and connect.
        self._reset()

    def sign(
            self,
            request_path,
            method,
            iso_timestamp,
    ):

        message_string = (
                iso_timestamp +
                method +
                request_path
        )
        hashed = hmac.new(
            base64.standard_b64encode(
                (self.api_key_credentials['secret']).encode(encoding='utf-8'),
            ),
            msg=message_string.encode(encoding='utf-8'),
            digestmod=hashlib.sha256,
        )
        return base64.standard_b64encode(hashed.digest()).decode()

    def runTimer(self):
        time_stamp = generate_now()
        ping = json.dumps({
            "op": "ping",
            "args": [str(time_stamp)]
        })
        self.ws.send(ping)
        #print("send ping:" + ping)

    def _on_open(self):
        """
        Log WS open.
        """

        logger.debug(f"WebSocket  opened.")

    def _on_message(self, message):
        """
        Parse incoming messages.
        """
        self.callback(json.loads(message))

    def _connect(self, url):
        """
        Open websocket in a thread.
        """
        self.private_websocket = True if url.__contains__("private") else False

        if hasattr(self, 'ws') and self.ws.sock and self.ws.sock.connected and hasattr(self, 'wst') and self.wst.is_alive() :
            logger.warning("WebSocket is already connected. Skipping reconnect.")
            return

        time_stamp = generate_now()
        self.ws = websocket.WebSocketApp(
            url=url + '&timestamp=' + str(time_stamp),
            on_message=lambda ws, msg: self._on_message(msg),
            on_close=self._on_close(),
            on_open=self._on_open(),
            on_error=lambda ws, err: self._on_error(err)
        )

        # Setup the thread running WebSocketApp.
        self.wst = threading.Thread(target=lambda: self.ws.run_forever(
            ping_interval=self.ping_interval,
            ping_timeout=self.ping_timeout
        ))

        # Configure as daemon; start.
        self.wst.daemon = True
        self.wst.start()

        # Attempt to connect for X seconds.
        retries = 10
        while retries > 0 and (not self.ws.sock or not self.ws.sock.connected):
            retries -= 1
            time.sleep(1)

        # If connection was not successful, raise error.
        if retries <= 0:
            self.exit()
            raise websocket.WebSocketTimeoutException("Connection failed.")

        # If given an api_key, authenticate.
        if self.api_key_credentials:
            self._auth(time_stamp)

    def _auth(self, time_stamp):
        """
        Authorize websocket connection.
        """

        signature = self.sign(
            request_path=PRIVATE_REQUEST_PATH,
            method='GET',
            iso_timestamp=str(time_stamp),
        )


        req = {
            'type': 'login',
            'topics': ['ws_notify_v1', 'ws_accounts_v2', 'ws_zk_accounts_v3','ws_accounts_v1'],
            'httpMethod': 'GET',
            'requestPath': PRIVATE_REQUEST_PATH,
            'apiKey': self.api_key_credentials['key'],
            'passphrase': self.api_key_credentials['passphrase'],
            'timestamp': time_stamp,
            'signature': signature,
        }
        sendStr = \
            {
                "op": "login",
                "args": [json.dumps(req)]
            }

        # Authenticate with API.
        self.ws.send(
            json.dumps(sendStr)
        )

    def _on_error(self, error):
        """
        Exit on errors and raise exception, or attempt reconnect.
        """

        if not self.exited:
            logger.error(f"WebSocket  encountered error: {error}.")
            self.exit()

        if hasattr(self, 'ws') and self.ws.sock and self.ws.sock.connected and hasattr(self, 'wst') and self.wst.is_alive() :
            logger.warning("WebSocket is already connected. Skipping reconnect.")
            return

        # Reconnect.
        if self.handle_error:
            self._reset()
            if self.private_websocket:
                self._connect(self.endpoint + PRIVATE_WSS)
            else:
                self._connect(self.endpoint + PUBLIC_WSS)

    def _on_close(self):
        """
        Log WS close.
        """
        logger.debug(f"WebSocket closed.")

    def _reset(self):
        """
        Set state booleans and initialize dictionary.
        """
        self.exited = False
        self.auth = False
        self.data = {}

    def exit(self):
        """
        Closes the websocket connection.
        """

        self.ws.close()
        while self.ws.sock:
            continue
        self.exited = True


class _ApexWebSocketManager(_WebSocketManager):
    def __init__(self, **kwargs):
        super().__init__(self._handle_incoming_message, **kwargs)

    def subscribe(self, sendStr, topic, callback):
        """
        Formats and sends the subscription message, given a topic. Saves the
        provided callback function, to be called by incoming messages.
        """

        if self.private_websocket:
            # Spot private topics don't need a subscription message
            self._set_callback(topic, callback)
            return

        self.ws.send(sendStr)
        self._set_callback(topic, callback)

    def _handle_incoming_message(self, message):
        #print(message)
        def is_ping_message():
            if type(message) == dict and message.get("op") == "ping":
                return True
            else:
                return False

        def is_auth_message():
            if type(message) == dict and \
                    message.get("request") is not None and message.get("request").get("op") is not None and message.get("request").get("op") == "login":
                return True
            else:
                return False

        def is_subscription_message():
            if type(message) == dict and \
                    message.get("request") is not None and message.get("request").get("op") is not None and message.get("request").get("op") == "subscribe":
                return True
            else:
                return False

        if is_ping_message():
            time_stamp = generate_now()
            pong = json.dumps({
                "op": "pong",
                "args": [str(time_stamp)]
            })
            self.ws.send(pong)
            #print("send pong:" + pong)
            return

        # Check auth
        if is_auth_message():
            # If we get successful spot auth, notify user
            if message.get("success") is not None and message.get("success") == "true":
                logger.debug(f"Authorization successful.")
                self.auth = True

        # Check subscription
        elif is_subscription_message():
            # If we get successful spot subscription, notify user
            if message.get("success") is not None and message.get("success") == "true":
                logger.debug(f"Subscription successful.")


        else:  # Standard topic push
                if message.get('topic') is not None and self.callback_directory.get(message.get('topic')) is not None:
                    callback_function = self.callback_directory[message['topic'] ]
                    callback_function(message)

    def _set_callback(self, topic, callback_function):
        self.callback_directory[topic] = callback_function

    def _get_callback(self, topic):
        return self.callback_directory[topic]

    def _pop_callback(self, topic):
        self.callback_directory.pop(topic)

    def _check_callback_directory(self, topics):
        for topic in topics:
            if topic in self.callback_directory:
                raise Exception(f"You have already subscribed to this topic: "
                                f"{topic}")


def _identify_ws_method(input_wss_url, wss_dictionary):
    """
    This method matches the input_wss_url with a particular WSS method. This
    helps ensure that, when subscribing to a custom topic, the topic
    subscription message is sent down the correct WSS connection.
    """
    path = re.compile("(wss://)?([^/\s]+)(.*)")
    input_wss_url_path = path.match(input_wss_url).group(3)
    for wss_url, function_call in wss_dictionary.items():
        wss_url_path = path.match(wss_url).group(3)
        if input_wss_url_path == wss_url_path:
            return function_call


def _find_index(source, target, key):
    """
    Find the index in source list of the targeted ID.
    """
    return next(i for i, j in enumerate(source) if j[key] == target[key])


def _make_public_kwargs(private_kwargs):
    public_kwargs = copy.deepcopy(private_kwargs)
    public_kwargs.pop("api_key_credentials", "")
    return public_kwargs












================================================
FILE: apexomni/constants.py
================================================
# ------------ API URLs ------------
APEX_HTTP_MAIN = 'https://pro.apex.exchange'
APEX_HTTP_TEST = 'https://testnet.pro.apex.exchange'
APEX_WS_MAIN = 'wss://quote.pro.apex.exchange'
APEX_WS_TEST = 'wss://quote-qa.pro.apex.exchange'

APEX_OMNI_HTTP_MAIN = 'https://omni.apex.exchange'
APEX_OMNI_HTTP_TEST = 'https://qa.omni.apex.exchange'

APEX_OMNI_WS_MAIN = 'wss://quote.omni.apex.exchange'
APEX_OMNI_WS_TEST = 'wss://qa-quote.omni.apex.exchange'

URL_SUFFIX = "/api"

# ------------ register_env_id ------------
REGISTER_ENVID_MAIN = 1
REGISTER_ENVID_TEST = 5

# ------------ network_id ------------
NETWORKID_MAIN = 1
NETWORKID_TEST = 11155111

NETWORKID_OMNI_MAIN_ARB = 9
NETWORKID_OMNI_TEST_BNB = 3
NETWORKID_OMNI_TEST_BASE = 11

# ------------ Signature Types ------------
SIGNATURE_TYPE_NO_PREPEND = 0
SIGNATURE_TYPE_DECIMAL = 1
SIGNATURE_TYPE_HEXADECIMAL = 2
SIGNATURE_TYPE_PERSONAL = 3


# ------------ Order Side ------------
ORDER_SIDE_BUY = 'BUY'
ORDER_SIDE_SELL = 'SELL'


# ------------ Assets ------------
ASSET_USDC = 'USDC'
ASSET_BTC = 'BTC'
ASSET_ETH = 'ETH'
ASSET_LINK = 'LINK'
ASSET_AAVE = 'AAVE'
ASSET_DOGE = 'DOGE'
ASSET_MATIC = 'MATIC'
COLLATERAL_ASSET = ASSET_USDC

ASSET_RESOLUTION = {
    ASSET_USDC: '1e6',
}

# ------------ Ethereum Transactions ------------
DEFAULT_GAS_AMOUNT = 250000
DEFAULT_GAS_MULTIPLIER = 1.5
DEFAULT_GAS_PRICE = 4000000000
DEFAULT_GAS_PRICE_ADDITION = 3
MAX_SOLIDITY_UINT = 115792089237316195423570985008687907853269984665640564039457584007913129639935  # noqa: E501


COLLATERAL_TOKEN_DECIMALS = 6

# ------------ Off-Chain Ethereum-Signed Actions ------------
OFF_CHAIN_ONBOARDING_ACTION = 'ApeX Onboarding' # action:ApeX Onboarding  onlySignOn:https://pro.apex.exchange nonce:1188491033265307648
OFF_CHAIN_KEY_DERIVATION_ACTION = 'L2 Key' #{"name": "ApeX","version": "1.0","envId": 1,"action": "L2 Key","onlySignOn": "https://pro.apex.exchange"}





================================================
FILE: apexomni/errors.py
================================================
class ApexproError(Exception):
    """Base error class for all exceptions raised in this library.
    Will never be raised naked; more specific subclasses of this exception will
    be raised when appropriate."""


class ApexproApiError(ApexproError):

    def __init__(self, response):
        self.status_code = response.status_code
        try:
            self.msg = response.json()
        except ValueError:
            self.msg = response.text
        self.response = response
        self.request = getattr(response, 'request', None)

    def __str__(self):
        return self.__repr__()

    def __repr__(self):
        return 'ApexproApiError(status_code={}, response={})'.format(
            self.status_code,
            self.msg,
        )


class TransactionReverted(ApexproError):

    def __init__(self, tx_receipt):
        self.tx_receipt = tx_receipt






================================================
FILE: apexomni/eth.py
================================================
import json
import os
from web3 import Web3

from apexomni.constants import ASSET_RESOLUTION
from apexomni.constants import COLLATERAL_ASSET
from apexomni.constants import DEFAULT_GAS_AMOUNT
from apexomni.constants import DEFAULT_GAS_MULTIPLIER
from apexomni.constants import DEFAULT_GAS_PRICE
from apexomni.constants import DEFAULT_GAS_PRICE_ADDITION
from apexomni.constants import MAX_SOLIDITY_UINT
from apexomni.errors import TransactionReverted

ERC20_ABI = 'abi/erc20.json'
STARKWARE_PERPETUALS_ABI = 'abi/starkware-perpetuals.json'
COLLATERAL_ASSET_RESOLUTION = float(ASSET_RESOLUTION[COLLATERAL_ASSET])


class Eth(object):

    def __init__(
        self,
        web3,
        network_id,
        eth_private_key,
        default_address,
        stark_public_key,
        send_options,
        collateral_asset_id,
        starware_perpetuals_contract,
        token_contracts,
    ):
        self.web3 = web3
        self.network_id = network_id
        self.eth_private_key = eth_private_key
        self.default_address = default_address
        self.stark_public_key = stark_public_key
        self.send_options = send_options

        self.collateral_asset_id = collateral_asset_id
        self.starware_perpetuals_contract = starware_perpetuals_contract
        self.token_contracts = token_contracts

        self.cached_contracts = {}
        self._next_nonce_for_address = {}

    # -----------------------------------------------------------
    # Helper Functions
    # -----------------------------------------------------------

    def create_contract(
        self,
        address,
        file_path,
    ):

        apex_folder = os.path.dirname(os.path.abspath(__file__))
        return self.web3.eth.contract(
            address=address,
            abi=json.load(open(os.path.join(apex_folder, file_path), 'r')),
        )

    def get_contract(
        self,
        address,
        file_path,
    ):
        if address not in self.cached_contracts:
            self.cached_contracts[address] = self.create_contract(
                address,
                file_path,
            )
        return self.cached_contracts[address]

    def get_exchange_contract(
        self,
        contract_address=None,
    ):
        if contract_address is None:
            contract_address = self.starware_perpetuals_contract
        if contract_address is None:
            raise ValueError(
                'Perpetuals exchange contract on network {}'.format(
                    self.network_id,
                )
            )
        contract_address = Web3.toChecksumAddress(contract_address)
        return self.get_contract(contract_address, STARKWARE_PERPETUALS_ABI)

    def get_token_contract(
        self,
        asset,
        token_address,
    ):
        if token_address is None:
            token_address = self.token_contracts
        if token_address is None:
            raise ValueError(
                'Token address unknown for asset {} on network {}'.format(
                    asset,
                    self.network_id,
                )
            )
        token_address = Web3.toChecksumAddress(token_address)
        return self.get_contract(token_address, ERC20_ABI)

    def send_eth_transaction(
        self,
        method=None,
        options=None,
    ):
        options = dict(self.send_options, **(options or {}))

        if 'from' not in options:
            options['from'] = self.default_address
        if options.get('from') is None:
            raise ValueError(
                "options['from'] is not set, and no default address is set",
            )
        auto_detect_nonce = 'nonce' not in options
        if auto_detect_nonce:
            options['nonce'] = self.get_next_nonce(options['from'])
        if 'gasPrice' not in options:
            try:
                options['gasPrice'] = (
                    self.web3.eth.gasPrice + DEFAULT_GAS_PRICE_ADDITION
                )
            except Exception:
                options['gasPrice'] = DEFAULT_GAS_PRICE
        if 'value' not in options:
            options['value'] = 0
        gas_multiplier = options.pop('gasMultiplier', DEFAULT_GAS_MULTIPLIER)
        if 'gas' not in options:
            try:
                options['gas'] = int(
                    method.estimateGas(options) * gas_multiplier
                )
            except Exception:
                options['gas'] = DEFAULT_GAS_AMOUNT

        signed = self.sign_tx(method, options)
        try:
            tx_hash = self.web3.eth.sendRawTransaction(signed.rawTransaction)
        except ValueError as error:
            while (
                auto_detect_nonce and
                (
                    'nonce too low' in str(error) or
                    'replacement transaction underpriced' in str(error)
                )
            ):
                try:
                    options['nonce'] += 1
                    signed = self.sign_tx(method, options)
                    tx_hash = self.web3.eth.sendRawTransaction(
                        signed.rawTransaction,
                    )
                except ValueError as inner_error:
                    error = inner_error
                else:
                    break  # Break on success...
            else:
                raise error  # ...and raise error otherwise.

        # Update next nonce for the account.
        self._next_nonce_for_address[options['from']] = options['nonce'] + 1

        return tx_hash.hex()

    def get_next_nonce(
        self,
        ethereum_address,
    ):
        if self._next_nonce_for_address.get(ethereum_address) is None:
            self._next_nonce_for_address[ethereum_address] = (
                self.web3.eth.getTransactionCount(ethereum_address)
            )
        return self._next_nonce_for_address[ethereum_address]

    def sign_tx(
        self,
        method,
        options,
    ):
        if method is None:
            tx = options
        else:
            tx = method.buildTransaction(options)
        return self.web3.eth.account.sign_transaction(
            tx,
            self.eth_private_key,
        )

    def wait_for_tx(
        self,
        tx_hash,
    ):
        '''
        Wait for a tx to be mined and return the receipt. Raise on revert.

        :param tx_hash: required
        :type tx_hash: number

        :returns: transactionReceipt

        :raises: TransactionReverted
        '''
        tx_receipt = self.web3.eth.waitForTransactionReceipt(tx_hash)
        if tx_receipt['status'] == 0:
            raise TransactionReverted(tx_receipt)

    # -----------------------------------------------------------
    # Transactions
    # -----------------------------------------------------------

    def register_user(
        self,
        registration_signature,
        stark_public_key=None,
        ethereum_address=None,
        send_options=None,
    ):
        '''
        Register a STARK key, using a signature provided by dYdX.

        :param registration_signature: required
        :type registration_signature: string

        :param stark_public_key: optional
        :type stark_public_key: string

        :param ethereum_address: optional
        :type ethereum_address: string

        :param send_options: optional
        :type send_options: dict

        :returns: transactionHash

        :raises: ValueError
        '''
        stark_public_key = stark_public_key or self.stark_public_key
        if stark_public_key is None:
            raise ValueError('No stark_public_key was provided')

        ethereum_address = ethereum_address or self.default_address
        if ethereum_address is None:
            raise ValueError(
                'ethereum_address was not provided, '
                'and no default address is set',
            )

        contract = self.get_exchange_contract()
        return self.send_eth_transaction(
            method=contract.functions.registerUser(
                ethereum_address,
                int(stark_public_key, 16),
                registration_signature,
            ),
            options=send_options,
        )

    def deposit_to_exchange(
        self,
        position_id,
        human_amount,
        stark_public_key=None,
        send_options=None,
    ):
        '''
        Deposit collateral to the L2 perpetuals exchange.

        :param position_id: required
        :type position_id: int or string

        :param human_amount: required
        :type human_amount: number or string

        :param stark_public_key: optional
        :type stark_public_key: string

        :param send_options: optional
        :type send_options: dict

        :returns: transactionHash

        :raises: ValueError
        '''
        stark_public_key = stark_public_key or self.stark_public_key
        if stark_public_key is None:
            raise ValueError('No stark_public_key was provided')

        contract = self.get_exchange_contract()
        return self.send_eth_transaction(
            method=contract.functions.deposit(
                int(stark_public_key, 16),
                int(self.collateral_asset_id, 16),
                int(position_id),
                int(float(human_amount) * COLLATERAL_ASSET_RESOLUTION),
            ),
            options=send_options,
        )

    def withdraw(
        self,
        stark_public_key=None,
        send_options=None,
    ):
        '''
        Withdraw from exchange.

        :param stark_public_key: optional
        :type stark_public_key: string

        :param send_options: optional
        :type send_options: dict

        :returns: transactionHash

        :raises: ValueError
        '''
        stark_public_key = stark_public_key or self.stark_public_key
        if stark_public_key is None:
            raise ValueError('No stark_public_key was provided')

        contract = self.get_exchange_contract()
        return self.send_eth_transaction(
            method=contract.functions.withdraw(
                int(stark_public_key, 16),
                int(self.collateral_asset_id, 16),
            ),
            options=send_options,
        )

    def withdraw_to(
        self,
        recipient,
        stark_public_key=None,
        send_options=None,
    ):
        '''
        Withdraw from exchange to address.

        :param recipient: required
        :type recipient: string

        :param stark_public_key: optional
        :type stark_public_key: string

        :param send_options: optional
        :type send_options: dict

        :returns: transactionHash

        :raises: ValueError
        '''
        stark_public_key = stark_public_key or self.stark_public_key
        if stark_public_key is None:
            raise ValueError('No stark_public_key was provided')

        contract = self.get_exchange_contract()
        return self.send_eth_transaction(
            method=contract.functions.withdrawTo(
                int(stark_public_key, 16),
                int(self.collateral_asset_id, 16),
                recipient,
            ),
            options=send_options,
        )

    def transfer_eth(
        self,
        to_address=None,  # Require keyword args to avoid confusing the amount.
        human_amount=None,
        send_options=None,
    ):
        '''
        Send Ethereum.

        :param to_address: required
        :type to_address: number

        :param human_amount: required
        :type human_amount: number or string

        :param send_options: optional
        :type send_options: dict

        :returns: transactionHash

        :raises: ValueError
        '''
        if to_address is None:
            raise ValueError('to_address is required')

        if human_amount is None:
            raise ValueError('human_amount is required')

        return self.send_eth_transaction(
            options=dict(
                send_options,
                to=to_address,
                value=Web3.toWei(human_amount, 'ether'),
            ),
        )

    def transfer_token(
        self,
        to_address=None,  # Require keyword args to avoid confusing the amount.
        human_amount=None,
        asset=COLLATERAL_ASSET,
        token_address=None,
        send_options=None,
    ):
        '''
        Send Ethereum.

        :param to_address: required
        :type to_address: number

        :param human_amount: required
        :type human_amount: number of string

        :param asset: optional
        :type asset: string

        :param token_address: optional
        :type asset: string

        :param send_options: optional
        :type send_options: dict

        :returns: transactionHash

        :raises: ValueError
        '''
        if to_address is None:
            raise ValueError('to_address is required')

        if human_amount is None:
            raise ValueError('human_amount is required')

        if asset not in ASSET_RESOLUTION:
            raise ValueError('Unknown asset {}'.format(asset))
        asset_resolution = ASSET_RESOLUTION[asset]

        contract = self.get_token_contract(asset, token_address)
        return self.send_eth_transaction(
            method=contract.functions.transfer(
                to_address,
                int(float(human_amount) * float(asset_resolution)),
            ),
            options=send_options,
        )

    def set_token_max_allowance(
        self,
        spender,
        asset=COLLATERAL_ASSET,
        token_address=None,
        send_options=None,
    ):
        '''
        Set max allowance for some spender for some asset or token_address.

        :param spender: required
        :type spender: string

        :param asset: optional
        :type asset: string

        :param token_address: optional
        :type asset: string

        :param send_options: optional
        :type send_options: dict

        :returns: transactionHash

        :raises: ValueError
        '''
        contract = self.get_token_contract(asset, token_address)
        return self.send_eth_transaction(
            method=contract.functions.approve(
                spender,
                MAX_SOLIDITY_UINT,
            ),
            options=send_options,
        )

    # -----------------------------------------------------------
    # Getters
    # -----------------------------------------------------------

    def get_eth_balance(
        self,
        owner=None,
    ):
        '''
        Get the owner's ether balance as a human readable amount.

        :param owner: optional
        :type owner: string

        :returns: string

        :raises: ValueError
        '''
        owner = owner or self.default_address
        if owner is None:
            raise ValueError(
                'owner was not provided, and no default address is set',
            )

        wei_balance = self.web3.eth.getBalance(owner)
        return Web3.fromWei(wei_balance, 'ether')

    def get_token_balance(
        self,
        owner=None,
        asset=COLLATERAL_ASSET,
        token_address=None,
    ):
        '''
        Get the owner's balance for some asset or token address.

        :param owner: optional
        :type owner: string

        :param asset: optional
        :type asset: string

        :param token_address: optional
        :type asset: string

        :returns: int
        '''
        owner = owner or self.default_address
        if owner is None:
            raise ValueError(
                'owner was not provided, and no default address is set',
            )

        contract = self.get_token_contract(asset, token_address)
        return contract.functions.balanceOf(owner).call()

    def get_token_allowance(
        self,
        spender,
        owner=None,
        asset=COLLATERAL_ASSET,
        token_address=None,
    ):
        '''
        Get allowance for some spender for some asset or token address.

        :param spender: required
        :type spender: string

        :param owner: optional
        :type owner: string

        :param asset: optional
        :type asset: string

        :param token_address: optional
        :type token_address: string

        :returns: int

        :raises: ValueError
        '''
        owner = owner or self.default_address
        if owner is None:
            raise ValueError(
                'owner was not provided, and no default address is set',
            )

        contract = self.get_token_contract(asset, token_address)
        return contract.functions.allowance(owner, spender).call()



================================================
FILE: apexomni/exceptions.py
================================================
class FailedRequestError(Exception):
    """
    Exception raised for failed requests.

    Attributes:
        request -- The original request that caused the error.
        message -- Explanation of the error.
        status_code -- The code number returned.
        time -- The time of the error.
    """
    def __init__(self, request, message, status_code, time):
        self.request = request
        self.message = message
        self.status_code = status_code
        self.time = time
        super().__init__(
            f'{message.capitalize()} (ErrCode: {status_code}) (ErrTime: {time})'
            f'.\nRequest  {request}.'
        )


class InvalidRequestError(Exception):
    """
    Exception raised for returned Apex pro errors.

    Attributes:
        request -- The original request that caused the error.
        message -- Explanation of the error.
        status_code -- The code number returned.
        time -- The time of the error.
    """
    def __init__(self, request, message, status_code, time):
        self.request = request
        self.message = message
        self.status_code = status_code
        self.time = time
        super().__init__(
            f'{message.capitalize()} (ErrCode: {status_code}) (ErrTime: {time})'
            f'.\nRequest  {request}.'
        )



================================================
FILE: apexomni/http_private.py
================================================
import base64
import hashlib
import hmac

from web3 import Web3

from apexomni import private_key_to_public_key_pair_hex
from apexomni.constants import URL_SUFFIX, OFF_CHAIN_KEY_DERIVATION_ACTION, OFF_CHAIN_ONBOARDING_ACTION
from apexomni.helpers.request_helpers import generate_query_path, \
    generate_now
from apexomni.http_public import HttpPublic


class HttpPrivate(HttpPublic):
    def _private_request(
            self,
            method,
            path,
            data={},
            headers=None
    ):
        now_iso = generate_now()
        if self.api_key_credentials is not None:
            signature = self.sign(
                request_path=path,
                method=method.upper(),
                iso_timestamp=str(now_iso),
                data=data,
            )
            headers = {
                'APEX-SIGNATURE': signature,
                'APEX-API-KEY': self.api_key_credentials.get('key'),
                'APEX-TIMESTAMP': str(now_iso),
                'APEX-PASSPHRASE': self.api_key_credentials.get('passphrase'),
            }
        return self._submit_request(
            method=method,
            path=self.endpoint + path,
            headers=headers,
            query=data,
        )

    def _get(self, endpoint, params):
        return self._private_request(
            'GET',
            generate_query_path(endpoint, params),
        )

    def _post(self, endpoint, data, headers=None):
        return self._private_request(
            'POST',
            endpoint,
            data,
            headers
        )

    # ============ Signing ============

    def sign(
            self,
            request_path,
            method,
            iso_timestamp,
            data,
    ):
        sortedItems=sorted(data.items(),key=lambda x:x[0],reverse=False)
        dataString = '&'.join('{key}={value}'.format(
            key=x[0], value=x[1]) for x in sortedItems if x[1] is not None)

        message_string = (
                iso_timestamp +
                method +
                request_path +
                dataString
        )
        hashed = hmac.new(
            base64.standard_b64encode(
                (self.api_key_credentials.get('secret')).encode(encoding='utf-8'),
            ),
            msg=message_string.encode(encoding='utf-8'),
            digestmod=hashlib.sha256,
        )
        return base64.standard_b64encode(hashed.digest()).decode()

    def generate_nonce(self, starkKey, ethAddress, chainId,
                       refresh="false"
                       ):
        """"
        POST: Generate nonce.
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#privateapi-post-generate-nonce
        :returns: Request results as dictionary.
        """

        path = URL_SUFFIX + "/v1/generate-nonce"
        return self._private_request(
            method="POST",
            path=path,
            data={
                'starkKey': starkKey,
                'ethAddress': ethAddress,
                'chainId': chainId,
                'category': 'CATEGORY_API',
                'refresh': refresh,
            }
        )

    def register_user(
            self,
            nonce,
            starkKey=None,
            stark_public_key_y_coordinate=None,
            ethereum_address=None,
            referred_by_affiliate_link=None,
            country=None,
            isLpAccount=None,
            eth_mul_address=None,
            sourceFlag=None,
    ):
        """"
        POST Registration & Onboarding.
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#privateapi-post-registration-amp-onboarding
        :returns: Request results as dictionary.
        """
        stark_key = starkKey or self.stark_public_key
        stark_key_y = (
                stark_public_key_y_coordinate or self.stark_public_key_y_coordinate
        )
        if stark_key is None:
            raise ValueError(
                'STARK private key or public key is required'
            )
        if stark_key_y is None:
            raise ValueError(
                'STARK private key or public key y-coordinate is required'
            )

        eth_address = ethereum_address or self.default_address
        signature = self.signer.sign(
            eth_address,
            action=OFF_CHAIN_ONBOARDING_ACTION,
            nonce=nonce,
        )

        path = URL_SUFFIX + "/v1/onboarding"
        onboardingRes = self._private_request(
            method="POST",
            path=path,
            data= {
                'starkKey': stark_key,
                'starkKeyYCoordinate': stark_key_y,
                'referredByAffiliateLink': referred_by_affiliate_link,
                'ethereumAddress': eth_address,
                'country': country,
                'category': 'CATEGORY_API',
                'isLpAccount': isLpAccount,
                'ethMulAddress': eth_mul_address,
                'sourceFlag': sourceFlag,
            },
            headers={
                'APEX-SIGNATURE': signature,
                'APEX-ETHEREUM-ADDRESS': eth_address,
            }
        )
        if onboardingRes.get('data') is not None:
            self.user = onboardingRes.get('data').get('user')
            self.account = onboardingRes.get('data').get('account')
        return onboardingRes

    def register_user_v2(
            self,
            nonce,
            starkKey=None,
            stark_public_key_y_coordinate=None,
            ethereum_address=None,
            referred_by_affiliate_link=None,
            country=None,
            isLpAccount=None,
            eth_mul_address=None,
            token=None,
            sourceFlag=None,
    ):
        """"
        POST Registration & Onboarding.
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#privateapi-post-registration-amp-onboarding
        :returns: Request results as dictionary.
        """
        stark_key = starkKey or self.stark_public_key
        stark_key_y = (
                stark_public_key_y_coordinate or self.stark_public_key_y_coordinate
        )
        if stark_key is None:
            raise ValueError(
                'STARK private key or public key is required'
            )
        if stark_key_y is None:
            raise ValueError(
                'STARK private key or public key y-coordinate is required'
            )

        eth_address = ethereum_address or self.default_address
        signature = self.signer.sign(
            eth_address,
            action=OFF_CHAIN_ONBOARDING_ACTION,
            nonce=nonce,
        )

        path = URL_SUFFIX + "/v2/onboarding-all"
        onboardingRes = self._private_request(
            method="POST",
            path=path,
            data= {
                'starkKey': stark_key,
                'starkKeyYCoordinate': stark_key_y,
                'referredByAffiliateLink': referred_by_affiliate_link,
                'ethereumAddress': eth_address,
                'country': country,
                'category': 'CATEGORY_API',
                'isLpAccount': isLpAccount,
                'ethMulAddress': eth_mul_address,
                'token':token,
                'sourceFlag': sourceFlag,
            },
            headers={
                'APEX-SIGNATURE': signature,
                'APEX-ETHEREUM-ADDRESS': eth_address,
            }
        )
        if onboardingRes.get('data') is not None:
            self.user = onboardingRes.get('data').get('user')
            self.account = onboardingRes.get('data').get('account')
        return onboardingRes

    def derive_stark_key(
            self,
            ethereum_address=None,
    ):
        signature = self.starkeySigner.sign_message(
            ethereum_address or self.default_address,
            action=OFF_CHAIN_KEY_DERIVATION_ACTION,
            )
        signature_int = int(signature, 16)
        hashed_signature = Web3.solidityKeccak(['uint256'], [signature_int])
        private_key_int = int(hashed_signature.hex(), 16) >> 5
        private_key_hex = hex(private_key_int)
        public_x, public_y = private_key_to_public_key_pair_hex(
            private_key_hex,
        )
        return {
            'public_key': public_x,
            'public_key_y_coordinate': public_y,
            'private_key': private_key_hex
        }


    def recover_api_key_credentials(
            self,
            nonce,
            ethereum_address=None,
    ):
        '''
        Derive API credentials deterministically from an Ethereum key.
        '''
        signature = self.signer.sign(
            ethereum_address or self.default_address,
            action=OFF_CHAIN_ONBOARDING_ACTION,
            nonce=nonce,
        )
        r_hex = signature[2:66]
        r_int = int(r_hex, 16)
        hashed_r_bytes = bytes(Web3.solidityKeccak(['uint256'], [r_int]))
        secret_bytes = hashed_r_bytes[:30]
        s_hex = signature[66:130]
        s_int = int(s_hex, 16)
        hashed_s_bytes = bytes(Web3.solidityKeccak(['uint256'], [s_int]))
        key_bytes = hashed_s_bytes[:16]
        passphrase_bytes = hashed_s_bytes[16:31]

        key_hex = key_bytes.hex()
        key_uuid = '-'.join([
            key_hex[:8],
            key_hex[8:12],
            key_hex[12:16],
            key_hex[16:20],
            key_hex[20:],
        ])

        return {
            'secret': base64.urlsafe_b64encode(secret_bytes).decode(),
            'key': key_uuid,
            'passphrase': base64.urlsafe_b64encode(passphrase_bytes).decode(),
        }

    def user(self, **kwargs):
        """"
        GET Retrieve User Data.
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#privateapi-get-retrieve-user-data
        :returns: Request results as dictionary.
        """

        path = URL_SUFFIX + "/v1/user"
        userRes = self._get(
            endpoint=path,
            params=kwargs
        )
        self.user = userRes.get('data')
        return userRes

    def get_user(self, **kwargs):
        """"
        GET Retrieve User Data.
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#privateapi-get-retrieve-user-data
        :returns: Request results as dictionary.
        """

        path = URL_SUFFIX + "/v1/user"
        userRes = self._get(
            endpoint=path,
            params=kwargs
        )
        self.user = userRes.get('data')
        return userRes


    def modify_user(self, **kwargs):
        """"
        POST Edit User Data.
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#privateapi-post-edit-user-data
        :returns: Request results as dictionary.
        """

        path = URL_SUFFIX + "/v1/modify-user"

        return self._post(
            endpoint=path,
            data=kwargs
        )

    def account(self, **kwargs):
        """"
        GET Retrieve User Account Data.
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#privateapi-get-retrieve-user-account-data
        :returns: Request results as dictionary.
        """

        path = URL_SUFFIX + "/v1/account"
        accountRes =  self._get(
            endpoint=path,
            params=kwargs
        )
        self.account = accountRes.get('data')
        return accountRes

    def get_account(self, **kwargs):
        """"
        GET Retrieve User Account Data.
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#privateapi-get-retrieve-user-account-data
        :returns: Request results as dictionary.
        """

        path = URL_SUFFIX + "/v1/account"
        accountRes =  self._get(
            endpoint=path,
            params=kwargs
        )
        self.account = accountRes.get('data')
        return accountRes

    def get_account_v2(self, **kwargs):
        """"
        GET Retrieve User Account Data.
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#privateapi-get-retrieve-user-account-data
        :returns: Request results as dictionary.
        """

        path = URL_SUFFIX + "/v2/account"
        accountRes =  self._get(
            endpoint=path,
            params=kwargs
        )
        self.account = accountRes.get('data')
        return accountRes

    def transfers(self, **kwargs):
        """"
        GET Retrieve User Deposit Data.
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#privateapi-get-retrieve-user-deposit-data
        :returns: Request results as dictionary.
        """

        path = URL_SUFFIX + "/v1/transfers"
        return self._get(
            endpoint=path,
            params=kwargs
        )

    def transfers_v2(self, **kwargs):
        """"
        GET Retrieve User Deposit Data.
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#privateapi-get-retrieve-user-deposit-data
        :returns: Request results as dictionary.
        """

        path = URL_SUFFIX + "/v2/transfers"
        return self._get(
            endpoint=path,
            params=kwargs
        )

    def withdraw_list(self, **kwargs):
        """"
        GET Retrieve User Withdrawal List.
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#privateapi-get-retrieve-user-withdrawal-list
        :returns: Request results as dictionary.
        """

        path = URL_SUFFIX + "/v1/withdraw-list"
        return self._get(
            endpoint=path,
            params=kwargs
        )
    def withdraw_list_v2(self, **kwargs):
        """"
        GET Retrieve User Withdrawal List.
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#privateapi-get-retrieve-user-withdrawal-list
        :returns: Request results as dictionary.
        """

        path = URL_SUFFIX + "/v2/withdraw-list"
        return self._get(
            endpoint=path,
            params=kwargs
        )
    def uncommon_withdraw_fee(self, **kwargs):
        """"
        GET Fast & Cross-Chain Withdrawal Fees.
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#privateapi-get-fast-amp-cross-chain-withdrawal-fees
        :returns: Request results as dictionary.
        """

        path = URL_SUFFIX + "/v1/uncommon-withdraw-fee"
        return self._get(
            endpoint=path,
            params=kwargs
        )

    def uncommon_withdraw_fee_v2(self, **kwargs):
        """"
        GET Fast & Cross-Chain Withdrawal Fees.
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#privateapi-get-fast-amp-cross-chain-withdrawal-fees
        :returns: Request results as dictionary.
        """

        path = URL_SUFFIX + "/v2/uncommon-withdraw-fee"
        return self._get(
            endpoint=path,
            params=kwargs
        )


    def transfer_limit(self, **kwargs):
        """"
        GET Retrieve Withdrawal & Transfer Limits.
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#privateapi-get-retrieve-withdrawal-amp-transfer-limits
        :returns: Request results as dictionary.
        """

        path = URL_SUFFIX + "/v1/transfer-limit"
        return self._get(
            endpoint=path,
            params=kwargs
        )

    def transfer_limit_v2(self, **kwargs):
        """"
        GET Retrieve Withdrawal & Transfer Limits.
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#privateapi-get-retrieve-withdrawal-amp-transfer-limits
        :returns: Request results as dictionary.
        """

        path = URL_SUFFIX + "/v2/transfer-limit"
        return self._get(
            endpoint=path,
            params=kwargs
        )

    def fills(self, **kwargs):
        """"
        GET Retrieve Trade History.
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#privateapi-get-retrieve-trade-history
        :returns: Request results as dictionary.
        """

        path = URL_SUFFIX + "/v1/fills"
        return self._get(
            endpoint=path,
            params=kwargs
        )

    def fills_v2(self, **kwargs):
        """"
        GET Retrieve Trade History.
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#privateapi-get-retrieve-trade-history
        :returns: Request results as dictionary.
        """

        path = URL_SUFFIX + "/v2/fills"
        return self._get(
            endpoint=path,
            params=kwargs
        )

    def order_fills_v2(self, **kwargs):

        path = URL_SUFFIX + "/v2/order-fills"
        return self._get(
            endpoint=path,
            params=kwargs
        )

    def delete_order(self, **kwargs):
        """"
        POST Cancel Order.
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#privateapi-post-cancel-order
        :returns: Request results as dictionary.
        """

        path = URL_SUFFIX + "/v1/delete-order"
        return self._post(
            endpoint=path,
            data=kwargs
        )


    def delete_order_v2(self, **kwargs):
        """"
        POST Cancel Order.
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#privateapi-post-cancel-order
        :returns: Request results as dictionary.
        """

        path = URL_SUFFIX + "/v2/delete-order"
        return self._post(
            endpoint=path,
            data=kwargs
        )

    def delete_order_by_client_order_id(self, **kwargs):
        """"
        POST Cancel Order.
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#privateapi-post-cancel-order
        :returns: Request results as dictionary.
        """

        path = URL_SUFFIX + "/v1/delete-client-order-id"
        return self._post(
            endpoint=path,
            data=kwargs
        )
    def delete_order_by_client_order_id_v2(self, **kwargs):
        """"
        POST Cancel Order.
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#privateapi-post-cancel-order
        :returns: Request results as dictionary.
        """

        path = URL_SUFFIX + "/v2/delete-client-order-id"
        return self._post(
            endpoint=path,
            data=kwargs
        )

    def delete_open_orders(self, **kwargs):
        """"
        POST Cancel all Open Orders
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#privateapi-post-cancel-all-open-orders
        :returns: Request results as dictionary.
        """

        path = URL_SUFFIX + "/v1/delete-open-orders"
        return self._post(
            endpoint=path,
            data=kwargs
        )

    def delete_open_orders_v2(self, **kwargs):
        """"
        POST Cancel all Open Orders
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#privateapi-post-cancel-all-open-orders
        :returns: Request results as dictionary.
        """

        path = URL_SUFFIX + "/v2/delete-open-orders"
        return self._post(
            endpoint=path,
            data=kwargs
        )
    def open_orders(self, **kwargs):
        """"
        GET Retrieve Open Orders.
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#privateapi-get-retrieve-open-orders
        :returns: Request results as dictionary.
        """

        path = URL_SUFFIX + "/v1/open-orders"
        return self._get(
            endpoint=path,
            params=kwargs
        )

    def open_orders_v2(self, **kwargs):
        """"
        GET Retrieve Open Orders.
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#privateapi-get-retrieve-open-orders
        :returns: Request results as dictionary.
        """

        path = URL_SUFFIX + "/v2/open-orders"
        return self._get(
            endpoint=path,
            params=kwargs
        )

    def history_orders(self, **kwargs):
        """"
        GET Retrieve All Order History.
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#privateapi-get-retrieve-all-order-history
        :returns: Request results as dictionary.
        """

        path = URL_SUFFIX + "/v1/history-orders"
        return self._get(
            endpoint=path,
            params=kwargs
        )

    def history_orders_v2(self, **kwargs):
        """"
        GET Retrieve All Order History.
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#privateapi-get-retrieve-all-order-history
        :returns: Request results as dictionary.
        """

        path = URL_SUFFIX + "/v2/history-orders"
        return self._get(
            endpoint=path,
            params=kwargs
        )

    def get_order(self, **kwargs):
        """"
        GET Retrieve Order ID.
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#privateapi-get-retrieve-order-id
        :returns: Request results as dictionary.
        """

        path = URL_SUFFIX + "/v1/get-order"
        return self._get(
            endpoint=path,
            params=kwargs
        )

    def get_order_v2(self, **kwargs):
        """"
        GET Retrieve Order ID.
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#privateapi-get-retrieve-order-id
        :returns: Request results as dictionary.
        """

        path = URL_SUFFIX + "/v2/get-order"
        return self._get(
            endpoint=path,
            params=kwargs
        )

    def get_order_by_client_order_id(self, **kwargs):
        """"
        GET Retrieve Order ID.
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#privateapi-get-retrieve-order-id
        :returns: Request results as dictionary.
        """

        path = URL_SUFFIX + "/v1/order-by-client-order-id"
        return self._get(
            endpoint=path,
            params=kwargs
        )

    def get_order_by_client_order_id_v2(self, **kwargs):
        """"
        GET Retrieve Order ID.
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#privateapi-get-retrieve-order-id
        :returns: Request results as dictionary.
        """

        path = URL_SUFFIX + "/v2/order-by-client-order-id"
        return self._get(
            endpoint=path,
            params=kwargs
        )

    def funding(self, **kwargs):
        """"
        GET Retrieve Funding Rate.
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#privateapi-get-retrieve-funding-rate
        :returns: Request results as dictionary.
        """

        path = URL_SUFFIX + "/v1/funding"
        return self._get(
            endpoint=path,
            params=kwargs
        )

    def funding_v2(self, **kwargs):
        """"
        GET Retrieve Funding Rate.
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#privateapi-get-retrieve-funding-rate
        :returns: Request results as dictionary.
        """

        path = URL_SUFFIX + "/v2/funding"
        return self._get(
            endpoint=path,
            params=kwargs
        )

    def notify_list(self, **kwargs):
        """"
        GET Retrieve Notification List.
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#privateapi-get-retrieve-notification-list
        :returns: Request results as dictionary.
        """

        path = URL_SUFFIX + "/v1/notify-list"
        return self._get(
            endpoint=path,
            params=kwargs
        )

    def mark_notify_read(self, **kwargs):
        """"
        POST Mark Notification As Read.
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#privateapi-post-mark-notification-as-read
        :returns: Request results as dictionary.
        """

        path = URL_SUFFIX + "/v1/mark-notify-read"
        return self._post(
            endpoint=path,
            data=kwargs
        )

    def historical_pnl(self, **kwargs):
        """"
        GET Retrieve User Historial Profit and Loss.
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#privateapi-get-retrieve-user-historial-profit-and-loss
        :returns: Request results as dictionary.
        """

        path = URL_SUFFIX + "/v1/historical-pnl"
        return self._get(
            endpoint=path,
            params=kwargs
        )

    def historical_pnl_v2(self, **kwargs):
        """"
        GET Retrieve User Historial Profit and Loss.
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#privateapi-get-retrieve-user-historial-profit-and-loss
        :returns: Request results as dictionary.
        """

        path = URL_SUFFIX + "/v2/historical-pnl"
        return self._get(
            endpoint=path,
            params=kwargs
        )

    def yesterday_pnl(self, **kwargs):
        """"
        GET Retrieve Yesterday's Profit & Loss.
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#privateapi-get-retrieve-yesterday-39-s-profit-amp-loss
        :returns: Request results as dictionary.
        """

        path = URL_SUFFIX + "/v1/yesterday-pnl"
        return self._get(
            endpoint=path,
            params=kwargs
        )

    def yesterday_pnl_v2(self, **kwargs):
        """"
        GET Retrieve Yesterday's Profit & Loss.
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#privateapi-get-retrieve-yesterday-39-s-profit-amp-loss
        :returns: Request results as dictionary.
        """

        path = URL_SUFFIX + "/v2/yesterday-pnl"
        return self._get(
            endpoint=path,
            params=kwargs
        )

    def history_value(self, **kwargs):
        """"
        GET Retrieve Historical Asset Value.
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#privateapi-get-retrieve-historical-asset-value
        :returns: Request results as dictionary.
        """

        path = URL_SUFFIX + "/v1/history-value"
        return self._get(
            endpoint=path,
            params=kwargs
        )

    def history_value_v2(self, **kwargs):
        """"
        GET Retrieve Historical Asset Value.
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#privateapi-get-retrieve-historical-asset-value
        :returns: Request results as dictionary.
        """

        path = URL_SUFFIX + "/v2/history-value"
        return self._get(
            endpoint=path,
            params=kwargs
        )

    def mark_all_notify_read(self, **kwargs):
        """"
        POST Mark All Notifications As Read.
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#privateapi-post-mark-all-notifications-as-read
        :returns: Request results as dictionary.
        """

        path = URL_SUFFIX + "/v1/mark-all-notify-read"
        return self._post(
            endpoint=path,
            data=kwargs
        )

    def mark_all_notify_read(self, **kwargs):
        """"
        POST Mark All Notifications As Read.
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#privateapi-post-mark-all-notifications-as-read
        :returns: Request results as dictionary.
        """

        path = URL_SUFFIX + "/v1/mark-all-notify-read"
        return self._post(
            endpoint=path,
            data=kwargs
        )

    def get_worst_price(self, **kwargs):
        """"
        get market price from orderbook
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#privateapi-get-retrieve-worst-price
        :returns: Request results as dictionary.
        """

        path = URL_SUFFIX + "/v1/get-worst-price"
        return self._get(
            endpoint=path,
            params=kwargs
        )

    def get_order_by_client_id(self, **kwargs):
        """"
        get market price from orderbook
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#privateapi-get-retrieve-worst-price
        :returns: Request results as dictionary.
        """

        path = URL_SUFFIX + "/v1/order-by-client-order-id"
        return self._get(
            endpoint=path,
            params=kwargs
        )

    def get_account_balance(self, **kwargs):
        """"
        get market price from orderbook
        :param kwargs: See
        https://api-docs.pro.apex.exchange/?lang=zh-TW#privateapi-get-retrieve-user-account-balance
        :returns: Request results as dictionary.
        """

        path = URL_SUFFIX + "/v1/account-balance"
        return self._get(
            endpoint=path,
            params=kwargs
        )

    def get_account_balance_v2(self, **kwargs):
        """"
        get market price from orderbook
        :param kwargs: See
        https://api-docs.pro.apex.exchange/?lang=zh-TW#privateapi-get-retrieve-user-account-balance
        :returns: Request results as dictionary.
        """

        path = URL_SUFFIX + "/v2/account-balance"
        return self._get(
            endpoint=path,
            params=kwargs
        )

    def gray_status(self, **kwargs):
        """"
        get market price from orderbook
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#privateapi-get-retrieve-worst-price
        :returns: Request results as dictionary.
        """

        path = URL_SUFFIX + "/v1/gray-status"
        return self._get(
            endpoint=path,
            params=kwargs
        )

    def set_initial_margin_rate(self, **kwargs):
        """"
        get market price from orderbook
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#privateapi-post-sets-the-initial-margin-rate-of-a-contract
        :returns: Request results as dictionary.
        """

        path = URL_SUFFIX + "/v1/set-initial-margin-rate"
        return self._post(
            endpoint=path,
            data=kwargs
        )

    def set_initial_margin_rate_v2(self, **kwargs):
        """"
        get market price from orderbook
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#privateapi-post-sets-the-initial-margin-rate-of-a-contract
        :returns: Request results as dictionary.
        """

        path = URL_SUFFIX + "/v2/set-initial-margin-rate"
        return self._post(
            endpoint=path,
            data=kwargs
        )

    def all_favorites(self, **kwargs):

        path = URL_SUFFIX + "/v1/all-favorites"
        return self._get(
            endpoint=path,
            params=kwargs
        )




================================================
FILE: apexomni/http_private_sign.py
================================================
import decimal
import hashlib
import time

import numpy as np
import json

from apexomni import zklink_sdk as sdk
from apexomni.constants import URL_SUFFIX, ORDER_SIDE_BUY
from apexomni.helpers.request_helpers import random_client_id
from apexomni.http_private_v3 import HttpPrivate_v3
from apexomni.starkex.order import DECIMAL_CONTEXT_ROUND_UP, DECIMAL_CONTEXT_ROUND_DOWN


class HttpPrivateSign(HttpPrivate_v3):
    def create_order_v3(self,
                     symbol,
                     side,
                     type,
                     size,
                     subAccountId=None,
                     takerFeeRate=None,
                     makerFeeRate=None,
                     price=None,
                     accountId=None,
                     timeInForce="GOOD_TIL_CANCEL",
                     reduceOnly=False,
                     triggerPrice=None,
                     triggerPriceType=None,
                     trailingPercent=None,
                     clientId=None,
                     timestampSeconds=None,
                     isPositionTpsl = False,
                     signature=None,
                     isOpenTpslOrder=False,
                     isSetOpenSl=False,
                     isSetOpenTp=False,
                     slClientId=None,
                     slPrice=None,
                     slSide=None,
                     slSize=None,
                     slTriggerPrice=None,
                     tpClientId=None,
                     tpPrice=None,
                     tpSide=None,
                     tpSize=None,
                     tpTriggerPrice=None,
                     sourceFlag=None,
                     brokerId=None,):
        """"
        POST  create_order.
        client.create_order(symbol="BTC-USDT", side="SELL",
                                           type="LIMIT", size="0.01",
                                           price="20000")

       :returns: Request results as dictionary.
       """
        price = str(price)
        size = str(size)
        clientId = clientId or random_client_id()

        accountId = accountId or self.accountV3.get('id')
        if not accountId:
            raise Exception(
                'No accountId provided' +
                'please call get_account_v3()'
            )

        if not self.configV3:
            raise Exception(
                'No config provided' +
                'please call configs_v3()'
            )
        symbolData = None
        currency = {}
        for k, v in enumerate(self.configV3.get('contractConfig').get('perpetualContract')):
            if v.get('symbol') == symbol or v.get('symbolDisplayName') == symbol:
                symbolData = v
        if symbolData is None:
            for k, v in enumerate(self.configV3.get('contractConfig').get('prelaunchContract')):
                if v.get('symbol') == symbol or v.get('symbolDisplayName') == symbol:
                    symbolData = v

        if symbolData is None:
            for k, v in enumerate(self.configV3.get('contractConfig').get('predictionContract')):
                if v.get('symbol') == symbol or v.get('symbolDisplayName') == symbol:
                    symbolData = v

        for k, v2 in enumerate(self.configV3.get('contractConfig').get('assets')):
            if v2.get('token') == symbolData.get('settleAssetId'):
                currency = v2

        if symbolData is not None :
            number = decimal.Decimal(price) / decimal.Decimal(symbolData.get('tickSize'))
            if number > int(number):
                raise Exception(
                    'the price must Multiple of tickSize'
                )

        if not self.zk_seeds:
            raise Exception(
                'No signature provided and client was not ' +
                'initialized with zk_seeds'
            )

        timestampSeconds = timestampSeconds or int(time.time())
        timestampSeconds = int(timestampSeconds + 3600 * 24 * 28)


        subAccountId = subAccountId or self.accountV3.get('spotAccount').get('defaultSubAccountId')
        takerFeeRate = takerFeeRate or self.accountV3.get('contractAccount').get('takerFeeRate')
        makerFeeRate = makerFeeRate or self.accountV3.get('contractAccount').get('makerFeeRate')

        message = hashlib.sha256()
        message.update(clientId.encode())  # Encode as UTF-8.
        nonceHash = message.hexdigest()
        nonceInt = int(nonceHash, 16)

        maxUint32 = np.iinfo(np.uint32).max
        maxUint64 = np.iinfo(np.uint64).max

        slotId = (nonceInt % maxUint64)/maxUint32
        nonce = nonceInt % maxUint32
        accountId = int(accountId, 10) % maxUint32


        priceStr = (decimal.Decimal(price) * decimal.Decimal(10) ** decimal.Decimal(currency.get('decimals'))).quantize(decimal.Decimal(0), rounding=decimal.ROUND_DOWN)
        sizeStr = (decimal.Decimal(size) * decimal.Decimal(10) ** decimal.Decimal(currency.get('decimals'))).quantize(decimal.Decimal(0), rounding=decimal.ROUND_DOWN)

        takerFeeRateStr =  (decimal.Decimal(takerFeeRate) * decimal.Decimal(10000)).quantize(decimal.Decimal(0), rounding=decimal.ROUND_UP)
        makerFeeRateStr =  (decimal.Decimal(makerFeeRate) * decimal.Decimal(10000)).quantize(decimal.Decimal(0), rounding=decimal.ROUND_UP)

        builder = sdk.ContractBuilder(
            int(accountId),  int(subAccountId), int(slotId), int(nonce),  int(symbolData.get('l2PairId')), sizeStr.__str__(), priceStr.__str__(), side == "BUY",  int(takerFeeRateStr), int(makerFeeRateStr),  False
        )


        tx = sdk.Contract(builder)
        seedsByte = bytes.fromhex(self.zk_seeds.removeprefix('0x') )
        signerSeed = sdk.ZkLinkSigner().new_from_seed(seedsByte)
        auth_data = signerSeed.sign_musig(tx.get_bytes())
        signature = auth_data.signature


        if side == ORDER_SIDE_BUY:
            human_cost = DECIMAL_CONTEXT_ROUND_UP.multiply(
                decimal.Decimal(size),
                decimal.Decimal(price)
            )
            fee = DECIMAL_CONTEXT_ROUND_UP.multiply(human_cost, decimal.Decimal(takerFeeRate))
        else:
            human_cost = DECIMAL_CONTEXT_ROUND_DOWN.multiply(
                decimal.Decimal(size),
                decimal.Decimal(price)
            )
            fee = DECIMAL_CONTEXT_ROUND_DOWN.multiply(human_cost, decimal.Decimal(takerFeeRate))

        limit_fee_rounded = DECIMAL_CONTEXT_ROUND_UP.quantize(
            decimal.Decimal(fee),
            decimal.Decimal("0.000001"), )

        sl_limit_fee_rounded = None
        slSignature = None
        slTriggerPriceType = None
        slExpiration = None
        tp_limit_fee_rounded = None
        tpSignature = None
        tpTriggerPriceType = None
        tpExpiration = None

        if isOpenTpslOrder == True:
            if isSetOpenSl == True:
                slPrice = str(slPrice)
                slSize = str(slSize)
                slTriggerPriceType = triggerPriceType
                slExpiration = timestampSeconds * 1000
                slClientId = slClientId or random_client_id()

                slMessage = hashlib.sha256()
                slMessage.update(slClientId.encode())  # Encode as UTF-8.
                slNonceHash = slMessage.hexdigest()
                slNonceInt = int(slNonceHash, 16)

                slSlotId = (slNonceInt % maxUint64)/maxUint32
                slNonce = slNonceInt % maxUint32

                slPriceStr = (decimal.Decimal(slPrice) * decimal.Decimal(10) ** decimal.Decimal(currency.get('decimals'))).quantize(decimal.Decimal(0), rounding=decimal.ROUND_DOWN)
                slSizeStr = (decimal.Decimal(slSize) * decimal.Decimal(10) ** decimal.Decimal(currency.get('decimals'))).quantize(decimal.Decimal(0), rounding=decimal.ROUND_DOWN)

                slBuilder = sdk.ContractBuilder(
                    int(accountId),  int(subAccountId), int(slSlotId), int(slNonce),  int(symbolData.get('l2PairId')), slSizeStr.__str__(), slPriceStr.__str__(), slSide == "BUY",  int(takerFeeRateStr), int(makerFeeRateStr),  False
                )

                slTx = sdk.Contract(slBuilder)
                sl_auth_data = signerSeed.sign_musig(slTx.get_bytes())
                slSignature = sl_auth_data.signature

                if slSide == ORDER_SIDE_BUY:
                    slHuman_cost = DECIMAL_CONTEXT_ROUND_UP.multiply(
                    decimal.Decimal(slSize),
                    decimal.Decimal(slPrice)
                    )
                    slFee = DECIMAL_CONTEXT_ROUND_UP.multiply(slHuman_cost, decimal.Decimal(takerFeeRate))
                else:
                    slHuman_cost = DECIMAL_CONTEXT_ROUND_DOWN.multiply(
                        decimal.Decimal(slSize),
                        decimal.Decimal(slPrice)
                    )
                    slFee = DECIMAL_CONTEXT_ROUND_DOWN.multiply(slHuman_cost, decimal.Decimal(takerFeeRate))

                sl_limit_fee_rounded = DECIMAL_CONTEXT_ROUND_UP.quantize(
                    decimal.Decimal(slFee),
                    decimal.Decimal("0.000001"), )

            if isSetOpenTp == True:
                tpPrice = str(tpPrice)
                tpSize = str(tpSize)
                tpTriggerPriceType = triggerPriceType
                tpExpiration = timestampSeconds * 1000
                tpClientId = tpClientId or random_client_id()

                tpMessage = hashlib.sha256()
                tpMessage.update(tpClientId.encode())  # Encode as UTF-8.
                tpNonceHash = tpMessage.hexdigest()
                tpNonceInt = int(tpNonceHash, 16)

                tpSlotId = (tpNonceInt % maxUint64)/maxUint32
                tpNonce = tpNonceInt % maxUint32

                tpPriceStr = (decimal.Decimal(tpPrice) * decimal.Decimal(10) ** decimal.Decimal(currency.get('decimals'))).quantize(decimal.Decimal(0), rounding=decimal.ROUND_DOWN)
                tpSizeStr = (decimal.Decimal(tpSize) * decimal.Decimal(10) ** decimal.Decimal(currency.get('decimals'))).quantize(decimal.Decimal(0), rounding=decimal.ROUND_DOWN)

                tpBuilder = sdk.ContractBuilder(
                    int(accountId),  int(subAccountId), int(tpSlotId), int(tpNonce),  int(symbolData.get('l2PairId')), tpSizeStr.__str__(), tpPriceStr.__str__(), tpSide == "BUY",  int(takerFeeRateStr), int(makerFeeRateStr),  False
                )

                tpTx = sdk.Contract(tpBuilder)
                tp_auth_data = signerSeed.sign_musig(tpTx.get_bytes())
                tpSignature = tp_auth_data.signature

                if tpSide == ORDER_SIDE_BUY:
                    tpHuman_cost = DECIMAL_CONTEXT_ROUND_UP.multiply(
                        decimal.Decimal(tpSize),
                        decimal.Decimal(tpPrice)
                    )
                    tpFee = DECIMAL_CONTEXT_ROUND_UP.multiply(tpHuman_cost, decimal.Decimal(takerFeeRate))
                else:
                    tpHuman_cost = DECIMAL_CONTEXT_ROUND_DOWN.multiply(
                        decimal.Decimal(tpSize),
                        decimal.Decimal(tpPrice)
                    )
                    tpFee = DECIMAL_CONTEXT_ROUND_DOWN.multiply(tpHuman_cost, decimal.Decimal(takerFeeRate))

                tp_limit_fee_rounded = DECIMAL_CONTEXT_ROUND_UP.quantize(
                    decimal.Decimal(tpFee),
                    decimal.Decimal("0.000001"), )

        order = {
            'symbol': symbol,
            'side': side,
            'type': type,
            'timeInForce': timeInForce,
            'size': size,
            'price': price,
            'limitFee': str(limit_fee_rounded),
            'expiration': timestampSeconds * 1000,
            'triggerPrice': triggerPrice,
            'triggerPriceType': triggerPriceType,
            'trailingPercent': trailingPercent,
            'clientId': clientId,
            'signature': signature,
            'reduceOnly': reduceOnly,
            'isPositionTpsl': isPositionTpsl,
            'isOpenTpslOrder': isOpenTpslOrder,
            'isSetOpenSl': isSetOpenSl,
            'isSetOpenTp': isSetOpenTp,
            'slClientOrderId': slClientId,
            'slPrice': slPrice,
            'slSide': slSide,
            'slSize': slSize,
            'slTriggerPrice': slTriggerPrice,
            'slTriggerPriceType': slTriggerPriceType,
            'slExpiration': slExpiration,
            'slLimitFee': str(sl_limit_fee_rounded),
            'slSignature': slSignature,
            'tpClientOrderId': tpClientId,
            'tpPrice': tpPrice,
            'tpSide': tpSide,
            'tpSize': tpSize,
            'tpTriggerPrice': tpTriggerPrice,
            'tpTriggerPriceType': tpTriggerPriceType,
            'tpExpiration': tpExpiration,
            'tpLimitFee': str(tp_limit_fee_rounded),
            'tpSignature': tpSignature,
            'sourceFlag': sourceFlag,
            'brokerId':brokerId,
        }

        path = URL_SUFFIX + "/v3/order"
        return self._post(
            endpoint=path,
            data=order
        )

    def create_withdrawal_v3(self,
                          amount,
                          toChainId,
                          asset,
                          nonce=None,
                          l2SourceTokenId=None,
                          l1TargetTokenId=None,
                          zkAccountId=None,
                          subAccountId=None,
                          fee='0',
                          clientId=None,
                          timestampSeconds=None,
                          ethAddress=None,
                          isFastWithdraw=False,
                          signature=None, ):

        clientId = clientId or random_client_id()
        if not self.zk_seeds:
            raise Exception(
                'No signature provided and client was not ' +
                'initialized with zk_seeds'
            )

        timestampSeconds =  int(timestampSeconds or int(time.time()))


        ethAddress = ethAddress or self.accountV3.get('ethereumAddress')

        zkAccountId = zkAccountId or self.accountV3.get('spotAccount').get('zkAccountId')

        subAccountId = subAccountId or self.accountV3.get('spotAccount').get('defaultSubAccountId')

        nonce = nonce or self.accountV3.get('spotAccount').get('subAccounts')[0].get('nonce')

        l2Key = self.zk_l2Key or self.accountV3.get('l2Key')
        if not ethAddress:
            raise Exception(
                'No ethAddress provided' +
                'please call get_user()'
            )


        if not self.configV3:
            raise Exception(
                'No config provided' +
                'please call configs_v3()'
            )

        currency = {}

        for k, v in enumerate(self.configV3.get('spotConfig').get('assets')):
            if v.get('token') == asset:
                currency = v

        l2SourceTokenId = l2SourceTokenId or currency.get('tokenId')
        l1TargetTokenId = l1TargetTokenId or currency.get('tokenId')

        withdraw_fee_ratio = 0
        if isFastWithdraw == True:
            withdraw_fee_ratio = decimal.Decimal(fee) * decimal.Decimal(10000) / decimal.Decimal(amount)
            withdraw_fee_ratio = withdraw_fee_ratio.quantize(decimal.Decimal(0), rounding=decimal.ROUND_UP)
            fee = (withdraw_fee_ratio * decimal.Decimal(amount) / 10000).__str__()


        amountStr = (decimal.Decimal(amount) * decimal.Decimal(10) ** decimal.Decimal(currency.get('decimals'))).quantize(decimal.Decimal(0), rounding=decimal.ROUND_UP)
        #feeStr = (decimal.Decimal(fee) * decimal.Decimal(10) ** decimal.Decimal(currency.get('decimals'))).quantize(decimal.Decimal(0), rounding=decimal.ROUND_UP)

        builder = sdk.WithdrawBuilder(
            int(zkAccountId),  int(subAccountId), int(toChainId),ethAddress, int(l2SourceTokenId),
            int(l1TargetTokenId), amountStr.__str__(), None, '0', int(nonce),  int(withdraw_fee_ratio),  False, int(timestampSeconds)
        )
        tx = sdk.Withdraw(builder)
        seedsByte = bytes.fromhex(self.zk_seeds.removeprefix('0x') )
        signerSeed = sdk.ZkLinkSigner().new_from_seed(seedsByte)

        auth_data = signerSeed.sign_musig(tx.get_bytes())
        signature = auth_data.signature

        withdraw = {
            'amount': amount,
            'timestamp': int(timestampSeconds),
            'ethAddress': ethAddress,
            'clientWithdrawId': clientId,
            'signature': signature,
            'zkAccountId': zkAccountId,
            'subAccountId': subAccountId,
            'l2Key': l2Key,
            'fee': str(fee),
            'toChainId': toChainId,
            'l2SourceTokenId': l2SourceTokenId,
            'l1TargetTokenId': l1TargetTokenId,
            'isFastWithdraw': isFastWithdraw,
            'nonce': nonce,
        }

        path = URL_SUFFIX + "/v3/withdrawal"
        return self._post(
            endpoint=path,
            data=withdraw
        )

    def create_transfer_out_v3(self,
                             amount,
                             asset,
                             nonce=None,
                             tokenId=None,
                             zkAccountId=None,
                             subAccountId=None,
                             fee='0',
                             clientId=None,
                             timestampSeconds=None,
                             receiverAccountId=None,
                             receiverZkAccountId=None,
                             receiverSubAccountId=None,
                             receiverAddress=None,
                             signature=None, ):

        clientId = clientId or random_client_id()
        if not self.zk_seeds:
            raise Exception(
                'No signature provided and client was not ' +
                'initialized with zk_seeds'
            )

        timestampSeconds =  int(timestampSeconds or int(time.time()))
        zkAccountId = zkAccountId or self.accountV3.get('spotAccount').get('zkAccountId')
        subAccountId = subAccountId or self.accountV3.get('spotAccount').get('defaultSubAccountId')
        nonce = nonce or self.accountV3.get('spotAccount').get('subAccounts')[0].get('nonce')

        receiverAddress = receiverAddress or self.configV3.get('spotConfig').get('global').get('contractAssetPoolEthAddress')
        receiverZkAccountId = receiverZkAccountId or self.configV3.get('spotConfig').get('global').get('contractAssetPoolZkAccountId')
        receiverSubAccountId = receiverSubAccountId or self.configV3.get('spotConfig').get('global').get('contractAssetPoolSubAccount')
        receiverAccountId = receiverAccountId or self.configV3.get('spotConfig').get('global').get('contractAssetPoolAccountId')

        if not self.configV3:
            raise Exception(
                'No config provided' +
                'please call configs_v3()'
            )

        currency = {}

        for k, v in enumerate(self.configV3.get('spotConfig').get('assets')):
            if v.get('token') == asset:
                currency = v

        tokenId = tokenId or currency.get('tokenId')

        amountStr = (decimal.Decimal(amount) * decimal.Decimal(10) ** decimal.Decimal(currency.get('decimals'))).quantize(decimal.Decimal(0), rounding=decimal.ROUND_UP)

        builder = sdk.TransferBuilder(
            int(zkAccountId),  receiverAddress, int(subAccountId), int(receiverSubAccountId), int(tokenId), amountStr.__str__(), '0', int(nonce),  int(timestampSeconds)
        )

        tx = sdk.Transfer(builder)
        seedsByte = bytes.fromhex(self.zk_seeds.removeprefix('0x') )
        signerSeed = sdk.ZkLinkSigner().new_from_seed(seedsByte)

        auth_data = signerSeed.sign_musig(tx.get_bytes())
        signature = auth_data.signature

        transferData = {
            'amount': amount,
            'timestamp': int(timestampSeconds),
            'clientTransferId': clientId,
            'signature': signature,
            'zkAccountId': zkAccountId,
            'subAccountId': subAccountId,
            'fee': str(fee),
            'token': asset,
            'tokenId': tokenId,
            'receiverAccountId': receiverAccountId,
            'receiverZkAccountId': receiverZkAccountId,
            'receiverSubAccountId': receiverSubAccountId,
            'receiverAddress': receiverAddress,
            'nonce': nonce,
        }

        path = URL_SUFFIX + "/v3/transfer-out"
        return self._post(
            endpoint=path,
            data=transferData
        )

    def create_transfer_out_to_address_v3(self,
                               amount,
                               asset,
                               nonce=None,
                               tokenId=None,
                               zkAccountId=None,
                               subAccountId=None,
                               fee='0',
                               clientId=None,
                               timestampSeconds=None,
                               receiverAccountId=None,
                               receiverZkAccountId=None,
                               receiverSubAccountId=None,
                               receiverAddress=None,
                               signature=None, ):

        clientId = clientId or random_client_id()
        if not self.zk_seeds:
            raise Exception(
                'No signature provided and client was not ' +
                'initialized with zk_seeds'
            )

        timestampSeconds =  int(timestampSeconds or int(time.time()))
        zkAccountId = zkAccountId or self.accountV3.get('spotAccount').get('zkAccountId')
        subAccountId = subAccountId or self.accountV3.get('spotAccount').get('defaultSubAccountId')
        nonce = nonce or self.accountV3.get('spotAccount').get('subAccounts')[0].get('nonce')

        receiverSubAccountId = receiverSubAccountId or 0

        if not self.configV3:
            raise Exception(
                'No config provided' +
                'please call configs_v3()'
            )

        currency = {}

        for k, v in enumerate(self.configV3.get('spotConfig').get('assets')):
            if v.get('token') == asset:
                currency = v

        tokenId = tokenId or currency.get('tokenId')

        amountStr = (decimal.Decimal(amount) * decimal.Decimal(10) ** decimal.Decimal(currency.get('decimals'))).quantize(decimal.Decimal(0), rounding=decimal.ROUND_UP)

        builder = sdk.TransferBuilder(
            int(zkAccountId),  receiverAddress, int(subAccountId), int(receiverSubAccountId), int(tokenId), amountStr.__str__(), '0', int(nonce),  int(timestampSeconds)
        )

        tx = sdk.Transfer(builder)
        seedsByte = bytes.fromhex(self.zk_seeds.removeprefix('0x') )
        signerSeed = sdk.ZkLinkSigner().new_from_seed(seedsByte)

        auth_data = signerSeed.sign_musig(tx.get_bytes())
        signature = auth_data.signature

        transferData = {
            'amount': amount,
            'timestamp': int(timestampSeconds),
            'clientTransferId': clientId,
            'signature': signature,
            'zkAccountId': zkAccountId,
            'subAccountId': subAccountId,
            'fee': str(fee),
            'token': asset,
            'tokenId': tokenId,
            'receiverAccountId': receiverAccountId,
            'receiverZkAccountId': receiverZkAccountId,
            'receiverSubAccountId': receiverSubAccountId,
            'receiverAddress': receiverAddress,
            'nonce': nonce,
        }

        path = URL_SUFFIX + "/v3/transfer-out-to-address"
        return self._post(
            endpoint=path,
            data=transferData
        )

    def create_contract_transfer_out_v3(self,
                                        amount,
                                        asset,
                                        nonce=None,
                                        tokenId=None,
                                        zkAccountId=None,
                                        subAccountId=None,
                                        ethAddress=None,
                                        clientId=None,
                                        timestampSeconds=None,
                                        accountId=None,
                                        receiverAccountId=None,
                                        receiverZkAccountId=None,
                                        receiverSubAccountId=None,
                                        receiverAddress=None,
                                        signature=None, ):

        clientId = clientId or random_client_id()
        if not self.zk_seeds:
            raise Exception(
             'No signature provided and client was not ' +
             'initialized with zk_seeds'
            )

        timestampSeconds =  timestampSeconds or int(time.time())
        timestampSeconds = int(timestampSeconds + 3600 * 24 * 28)
        accountId = accountId or self.accountV3.get('id')
        subAccountId = subAccountId or self.accountV3.get('spotAccount').get('defaultSubAccountId')

        ethAddress = ethAddress or self.accountV3.get('ethereumAddress')

        receiverSubAccountId = receiverSubAccountId or 0

        message = hashlib.sha256()
        message.update(clientId.encode())  # Encode as UTF-8.
        nonceHash = message.hexdigest()
        nonceInt = int(nonceHash, 16)
        maxUint32 = np.iinfo(np.uint32).max


        nonce = nonceInt % maxUint32
        accountId = int(accountId, 10) % maxUint32

        if not self.configV3:
            raise Exception(
               'No config provided' +
               'please call configs_v3()'
            )

        currency = {}

        for k, v in enumerate(self.configV3.get('contractConfig').get('assets')):
            if v.get('token') == asset:
                currency = v

        tokenId = tokenId or currency.get('tokenId')

        amountStr = (decimal.Decimal(amount) * decimal.Decimal(10) ** decimal.Decimal(currency.get('decimals'))).quantize(decimal.Decimal(0), rounding=decimal.ROUND_UP)

        builder = sdk.TransferBuilder(
            int(accountId),  ethAddress, int(subAccountId), int(receiverSubAccountId),  int(tokenId), amountStr.__str__(), '0', int(nonce),  int(timestampSeconds)
        )

        tx = sdk.Transfer(builder)
        seedsByte = bytes.fromhex(self.zk_seeds.removeprefix('0x') )
        signerSeed = sdk.ZkLinkSigner().new_from_seed(seedsByte)

        auth_data = signerSeed.sign_musig(tx.get_bytes())
        signature = auth_data.signature

        transferData = {
            'amount': amount,
            'expireTime': timestampSeconds,
            'clientWithdrawId': clientId,
            'signature': signature,
            'token': asset,
            'ethAddress': ethAddress,
        }

        path = URL_SUFFIX + "/v3/contract-transfer-out"
        return self._post(
            endpoint=path,
            data=transferData
        )

    def create_contract_transfer_to_address_v3(self,
                                        amount,
                                        asset,
                                        receiverL2Key,
                                        receiverAccountId,
                                        receiverAddress,
                                        receiverSubAccountId=None,
                                        nonce=None,
                                        tokenId=None,
                                        subAccountId=None,
                                        clientId=None,
                                        timestampSeconds=None,
                                        accountId=None,
                                        signature=None, ):

        clientId = clientId or random_client_id()
        if not self.zk_seeds:
            raise Exception(
                'No signature provided and client was not ' +
                'initialized with zk_seeds'
            )

        timestampSeconds =  timestampSeconds or int(time.time())
        timestampSeconds = int(timestampSeconds + 3600 * 24 * 28)
        accountId = accountId or self.accountV3.get('id')
        subAccountId = subAccountId or self.accountV3.get('spotAccount').get('defaultSubAccountId')
        receiverSubAccountId = receiverSubAccountId or 0

        message = hashlib.sha256()
        message.update(clientId.encode())  # Encode as UTF-8.
        nonceHash = message.hexdigest()
        nonceInt = int(nonceHash, 16)
        maxUint32 = np.iinfo(np.uint32).max


        nonce = nonceInt % maxUint32
        accountId = int(accountId, 10) % maxUint32

        if not self.configV3:
            raise Exception(
                'No config provided' +
                'please call configs_v3()'
            )

        currency = {}

        for k, v in enumerate(self.configV3.get('contractConfig').get('assets')):
            if v.get('token') == asset:
                currency = v

        tokenId = tokenId or currency.get('tokenId')

        amountStr = (decimal.Decimal(amount) * decimal.Decimal(10) ** decimal.Decimal(currency.get('decimals'))).quantize(decimal.Decimal(0), rounding=decimal.ROUND_UP)

        builder = sdk.TransferBuilder(
            int(accountId),  receiverAddress, int(subAccountId), int(receiverSubAccountId),  int(tokenId), amountStr.__str__(), '0', int(nonce),  int(timestampSeconds)
        )

        tx = sdk.Transfer(builder)
        seedsByte = bytes.fromhex(self.zk_seeds.removeprefix('0x') )
        signerSeed = sdk.ZkLinkSigner().new_from_seed(seedsByte)

        auth_data = signerSeed.sign_musig(tx.get_bytes())
        signature = auth_data.signature

        transferData = {
            'amount': amount,
            'expireTime': timestampSeconds,
            'clientTransferId': clientId,
            'signature': signature,
            'token': asset,
            'receiverAccountId': receiverAccountId,
            'receiverL2Key': receiverL2Key,
        }

        path = URL_SUFFIX + "/v3/contract-transfer-to"
        return self._post(
            endpoint=path,
            data=transferData
        )

    def create_manual_repayment_v3(self,
                                   repaymentTokens,
                                   poolRepaymentTokens,
                                   clientId=None,
                                   timestampSeconds=None,
                                   accountId=None,
                                   signature=None, ):

        clientId = clientId or random_client_id()
        if not self.zk_seeds:
            raise Exception(
                'No signature provided and client was not ' +
                'initialized with zk_seeds'
            )

        timestampSeconds =  timestampSeconds or int(time.time())
        timestampSeconds = int(timestampSeconds + 3600 * 24 * 28)
        accountId = accountId or self.accountV3.get('id')

        msgHashString ="accountId=" + accountId + "&clientId=" + clientId + "&expireTime=" + str(timestampSeconds) + "&repaymentTokens=" + repaymentTokens

        message = hashlib.sha256()
        message.update(msgHashString.encode())  # Encode as UTF-8.
        msgHash = message.digest()

        EC_ORDER = '3618502788666131213697322783095070105526743751716087489154079457884512865583';

        bn1 = int(msgHash.hex(), 16)
        bn2 = int (EC_ORDER, 10)
        signMsg = hex(bn1.__mod__(bn2))

        seedsByte = bytes.fromhex(self.zk_seeds.removeprefix('0x') )
        signerSeed = sdk.ZkLinkSigner().new_from_seed(seedsByte)
        signatureData = signerSeed.sign_musig(signMsg.removeprefix('0x').encode())
        signature = signatureData.signature

        repaymentData = {
            'repaymentTokens': repaymentTokens,
            'expireTime': timestampSeconds,
            'clientId': clientId,
            'signature': signature,
            'poolRepaymentTokens': poolRepaymentTokens,
        }

        path = URL_SUFFIX + "/v3/manual-create-repayment"
        return self._post(
            endpoint=path,
            data=repaymentData
        )

    def create_batch_orders_v3(self, orders):
        createOrders = []
        for orderModel in orders:
            price = str(orderModel.price)
            size = str(orderModel.size)
            clientId = orderModel.clientId or random_client_id()

            accountId = orderModel.accountId or self.accountV3.get('id')
            if not accountId:
                raise Exception(
                    'No accountId provided' +
                    'please call get_account_v3()'
                )

            if not self.configV3:
                raise Exception(
                    'No config provided' +
                    'please call configs_v3()'
                )
            symbolData = None
            currency = {}
            for k, v in enumerate(self.configV3.get('contractConfig').get('perpetualContract')):
                if v.get('symbol') == orderModel.symbol or v.get('symbolDisplayName') == orderModel.symbol:
                    symbolData = v
            if symbolData is None:
                for k, v in enumerate(self.configV3.get('contractConfig').get('prelaunchContract')):
                    if v.get('symbol') == orderModel.symbol or v.get('symbolDisplayName') == orderModel.symbol:
                        symbolData = v
            if symbolData is None:
                for k, v in enumerate(self.configV3.get('contractConfig').get('predictionContract')):
                    if v.get('symbol') == orderModel.symbol or v.get('symbolDisplayName') == orderModel.symbol:
                        symbolData = v

            for k, v2 in enumerate(self.configV3.get('contractConfig').get('assets')):
                if v2.get('token') == symbolData.get('settleAssetId'):
                    currency = v2

            if symbolData is not None :
                number = decimal.Decimal(price) / decimal.Decimal(symbolData.get('tickSize'))
                if number > int(number):
                    raise Exception(
                        'the price must Multiple of tickSize'
                    )

            if not self.zk_seeds:
                raise Exception(
                    'No signature provided and client was not ' +
                    'initialized with zk_seeds'
                )

            timestampSeconds = orderModel.timestampSeconds or int(time.time())
            timestampSeconds = int(timestampSeconds + 3600 * 24 * 28)


            subAccountId = orderModel.subAccountId or self.accountV3.get('spotAccount').get('defaultSubAccountId')
            takerFeeRate = orderModel.takerFeeRate or self.accountV3.get('contractAccount').get('takerFeeRate')
            makerFeeRate = orderModel.makerFeeRate or self.accountV3.get('contractAccount').get('makerFeeRate')

            message = hashlib.sha256()
            message.update(clientId.encode())  # Encode as UTF-8.
            nonceHash = message.hexdigest()
            nonceInt = int(nonceHash, 16)

            maxUint32 = np.iinfo(np.uint32).max
            maxUint64 = np.iinfo(np.uint64).max

            slotId = (nonceInt % maxUint64)/maxUint32
            nonce = nonceInt % maxUint32
            accountId = int(accountId, 10) % maxUint32


            priceStr = (decimal.Decimal(price) * decimal.Decimal(10) ** decimal.Decimal(currency.get('decimals'))).quantize(decimal.Decimal(0), rounding=decimal.ROUND_DOWN)
            sizeStr = (decimal.Decimal(size) * decimal.Decimal(10) ** decimal.Decimal(currency.get('decimals'))).quantize(decimal.Decimal(0), rounding=decimal.ROUND_DOWN)

            takerFeeRateStr =  (decimal.Decimal(takerFeeRate) * decimal.Decimal(10000)).quantize(decimal.Decimal(0), rounding=decimal.ROUND_UP)
            makerFeeRateStr =  (decimal.Decimal(makerFeeRate) * decimal.Decimal(10000)).quantize(decimal.Decimal(0), rounding=decimal.ROUND_UP)

            builder = sdk.ContractBuilder(
                int(accountId),  int(subAccountId), int(slotId), int(nonce),  int(symbolData.get('l2PairId')), sizeStr.__str__(), priceStr.__str__(), orderModel.side == "BUY",  int(takerFeeRateStr), int(makerFeeRateStr),  False
            )


            tx = sdk.Contract(builder)
            seedsByte = bytes.fromhex(self.zk_seeds.removeprefix('0x') )
            signerSeed = sdk.ZkLinkSigner().new_from_seed(seedsByte)
            auth_data = signerSeed.sign_musig(tx.get_bytes())
            signature = auth_data.signature


            if orderModel.side == ORDER_SIDE_BUY:
                human_cost = DECIMAL_CONTEXT_ROUND_UP.multiply(
                    decimal.Decimal(size),
                    decimal.Decimal(price)
                )
                fee = DECIMAL_CONTEXT_ROUND_UP.multiply(human_cost, decimal.Decimal(takerFeeRate))
            else:
                human_cost = DECIMAL_CONTEXT_ROUND_DOWN.multiply(
                    decimal.Decimal(size),
                    decimal.Decimal(price)
                )
                fee = DECIMAL_CONTEXT_ROUND_DOWN.multiply(human_cost, decimal.Decimal(takerFeeRate))

            limit_fee_rounded = DECIMAL_CONTEXT_ROUND_UP.quantize(
                decimal.Decimal(fee),
                decimal.Decimal("0.000001"), )

            sl_limit_fee_rounded = None
            slSignature = None
            slTriggerPriceType = None
            slExpiration = None
            tp_limit_fee_rounded = None
            tpSignature = None
            tpTriggerPriceType = None
            tpExpiration = None

            if orderModel.isOpenTpslOrder == True:
                if orderModel.isSetOpenSl == True:
                    slTriggerPriceType = orderModel.triggerPriceType
                    slExpiration = timestampSeconds * 1000
                    slClientId = orderModel.slClientId or random_client_id()

                    slMessage = hashlib.sha256()
                    slMessage.update(slClientId.encode())  # Encode as UTF-8.
                    slNonceHash = slMessage.hexdigest()
                    slNonceInt = int(slNonceHash, 16)

                    slSlotId = (slNonceInt % maxUint64)/maxUint32
                    slNonce = slNonceInt % maxUint32

                    slPriceStr = (decimal.Decimal(str(orderModel.slPrice)) * decimal.Decimal(10) ** decimal.Decimal(currency.get('decimals'))).quantize(decimal.Decimal(0), rounding=decimal.ROUND_DOWN)
                    slSizeStr = (decimal.Decimal(str(orderModel.slSize)) * decimal.Decimal(10) ** decimal.Decimal(currency.get('decimals'))).quantize(decimal.Decimal(0), rounding=decimal.ROUND_DOWN)

                    slBuilder = sdk.ContractBuilder(
                        int(accountId),  int(subAccountId), int(slSlotId), int(slNonce),  int(symbolData.get('l2PairId')), slSizeStr.__str__(), slPriceStr.__str__(), slSide == "BUY",  int(takerFeeRateStr), int(makerFeeRateStr),  False
                    )

                    slTx = sdk.Contract(slBuilder)
                    sl_auth_data = signerSeed.sign_musig(slTx.get_bytes())
                    slSignature = sl_auth_data.signature

                    if orderModel.slSide == ORDER_SIDE_BUY:
                        slHuman_cost = DECIMAL_CONTEXT_ROUND_UP.multiply(
                            decimal.Decimal(str(orderModel.slSize)),
                            decimal.Decimal(str(orderModel.slPrice))
                        )
                        slFee = DECIMAL_CONTEXT_ROUND_UP.multiply(slHuman_cost, decimal.Decimal(takerFeeRate))
                    else:
                        slHuman_cost = DECIMAL_CONTEXT_ROUND_DOWN.multiply(
                            decimal.Decimal(str(orderModel.slSize)),
                            decimal.Decimal(str(orderModel.slPrice))
                        )
                        slFee = DECIMAL_CONTEXT_ROUND_DOWN.multiply(slHuman_cost, decimal.Decimal(takerFeeRate))

                    sl_limit_fee_rounded = DECIMAL_CONTEXT_ROUND_UP.quantize(
                        decimal.Decimal(slFee),
                        decimal.Decimal("0.000001"), )

                if orderModel.isSetOpenTp == True:
                    tpTriggerPriceType = orderModel.triggerPriceType
                    tpExpiration = timestampSeconds * 1000
                    tpClientId = orderModel.tpClientId or random_client_id()

                    tpMessage = hashlib.sha256()
                    tpMessage.update(tpClientId.encode())  # Encode as UTF-8.
                    tpNonceHash = tpMessage.hexdigest()
                    tpNonceInt = int(tpNonceHash, 16)

                    tpSlotId = (tpNonceInt % maxUint64)/maxUint32
                    tpNonce = tpNonceInt % maxUint32

                    tpPriceStr = (decimal.Decimal(str(orderModel.tpPrice)) * decimal.Decimal(10) ** decimal.Decimal(currency.get('decimals'))).quantize(decimal.Decimal(0), rounding=decimal.ROUND_DOWN)
                    tpSizeStr = (decimal.Decimal(str(orderModel.tpSize)) * decimal.Decimal(10) ** decimal.Decimal(currency.get('decimals'))).quantize(decimal.Decimal(0), rounding=decimal.ROUND_DOWN)

                    tpBuilder = sdk.ContractBuilder(
                        int(accountId),  int(subAccountId), int(tpSlotId), int(tpNonce),  int(symbolData.get('l2PairId')), tpSizeStr.__str__(), tpPriceStr.__str__(), tpSide == "BUY",  int(takerFeeRateStr), int(makerFeeRateStr),  False
                    )

                    tpTx = sdk.Contract(tpBuilder)
                    tp_auth_data = signerSeed.sign_musig(tpTx.get_bytes())
                    tpSignature = tp_auth_data.signature

                    if orderModel.tpSide == ORDER_SIDE_BUY:
                        tpHuman_cost = DECIMAL_CONTEXT_ROUND_UP.multiply(
                            decimal.Decimal(str(orderModel.tpSize)),
                            decimal.Decimal(str(orderModel.tpPrice))
                        )
                        tpFee = DECIMAL_CONTEXT_ROUND_UP.multiply(tpHuman_cost, decimal.Decimal(takerFeeRate))
                    else:
                        tpHuman_cost = DECIMAL_CONTEXT_ROUND_DOWN.multiply(
                            decimal.Decimal(str(orderModel.tpSize)),
                            decimal.Decimal(str(orderModel.tpPrice))
                        )
                        tpFee = DECIMAL_CONTEXT_ROUND_DOWN.multiply(tpHuman_cost, decimal.Decimal(takerFeeRate))

                    tp_limit_fee_rounded = DECIMAL_CONTEXT_ROUND_UP.quantize(
                        decimal.Decimal(tpFee),
                        decimal.Decimal("0.000001"), )

            order = {
                'symbol': orderModel.symbol,
                'side': orderModel.side,
                'type': orderModel.type,
                'timeInForce': orderModel.timeInForce,
                'size': size,
                'price': price,
                'limitFee': str(limit_fee_rounded),
                'expiration': timestampSeconds * 1000,
                'triggerPrice': orderModel.triggerPrice,
                'triggerPriceType': orderModel.triggerPriceType,
                'trailingPercent': orderModel.trailingPercent,
                'clientId': clientId,
                'signature': signature,
                'reduceOnly': orderModel.reduceOnly,
                'isPositionTpsl': orderModel.isPositionTpsl,
                'isOpenTpslOrder': orderModel.isOpenTpslOrder,
                'isSetOpenSl': orderModel.isSetOpenSl,
                'isSetOpenTp': orderModel.isSetOpenTp,
                'slClientOrderId': orderModel.slClientId,
                'slPrice': orderModel.slPrice,
                'slSide': orderModel.slSide,
                'slSize': orderModel.slSize,
                'slTriggerPrice': orderModel.slTriggerPrice,
                'slTriggerPriceType': slTriggerPriceType,
                'slExpiration': slExpiration,
                'slLimitFee': str(sl_limit_fee_rounded),
                'slSignature': slSignature,
                'tpClientOrderId': orderModel.tpClientId,
                'tpPrice': orderModel.tpPrice,
                'tpSide': orderModel.tpSide,
                'tpSize': orderModel.tpSize,
                'tpTriggerPrice': orderModel.tpTriggerPrice,
                'tpTriggerPriceType': tpTriggerPriceType,
                'tpExpiration': tpExpiration,
                'tpLimitFee': str(tp_limit_fee_rounded),
                'tpSignature': tpSignature,
                'sourceFlag': orderModel.sourceFlag,
                'brokerId':orderModel.brokerId,
            }
            createOrders.append(order)
        path = URL_SUFFIX + "/v3/batch-orders"
        return self._post(
            endpoint=path,
            data= {'orders':json.dumps(createOrders)}
        )



================================================
FILE: apexomni/http_private_stark_key_sign.py
================================================
import decimal
import decimal
import math

from apexomni.constants import URL_SUFFIX, ORDER_SIDE_BUY
from apexomni.helpers.request_helpers import random_client_id, iso_to_epoch_seconds, epoch_seconds_to_iso
from apexomni.http_private import HttpPrivate
from apexomni.starkex.conditional_transfer import SignableConditionalTransfer
from apexomni.starkex.constants import ONE_HOUR_IN_SECONDS, ORDER_SIGNATURE_EXPIRATION_BUFFER_HOURS
from apexomni.starkex.helpers import get_transfer_erc20_fact, nonce_from_client_id
from apexomni.starkex.order import SignableOrder, DECIMAL_CONTEXT_ROUND_UP, DECIMAL_CONTEXT_ROUND_DOWN
from apexomni.starkex.transfer import SignableTransfer
from apexomni.starkex.withdrawal import SignableWithdrawal


class HttpPrivateStark(HttpPrivate):
    def create_order(self,
                     symbol,
                     side,
                     type,
                     size,
                     limitFeeRate=None,
                     limitFee=None,
                     price=None,
                     accountId=None,
                     timeInForce="GOOD_TIL_CANCEL",
                     reduceOnly=False,
                     triggerPrice=None,
                     triggerPriceType="INDEX",
                     trailingPercent=None,
                     clientId=None,
                     expiration=None,
                     expirationEpochSeconds=None,
                     isPositionTpsl = False,
                     signature=None,
                     isOpenTpslOrder=False,
                     isSetOpenSl=False,
                     isSetOpenTp=False,
                     slClientId=None,
                     slPrice=None,
                     slSide=None,
                     slSize=None,
                     slTriggerPrice=None,
                     tpClientId=None,
                     tpPrice=None,
                     tpSide=None,
                     tpSize=None,
                     tpTriggerPrice=None,
                     sourceFlag=None,
                     brokerId=None,):
        """"
        POST  create_order.
        client.create_order(symbol="BTC-USDC", side="SELL",
                                           type="LIMIT", size="0.01",
                                           price="20000", limitFeeRate="1",
                                            accountId="325881046451093849",reduceOnly=False,
                                           expiration=now_iso + SEVEN_DAYS_S + 60*1000, timeInForce="GOOD_TIL_CANCEL")

       :returns: Request results as dictionary.
       """
        price = str(price)
        size = str(size)
        clientId = clientId or random_client_id()
        if not self.stark_private_key:
            raise Exception(
                'No signature provided and client was not ' +
                'initialized with stark_private_key'
            )

        if bool(expiration) == bool(expirationEpochSeconds):
            raise ValueError(
                'Exactly one of expiration and expiration_epoch_seconds must '
                'be specified',
            )
        expiration = expiration or epoch_seconds_to_iso(
            expirationEpochSeconds,
        )
        expirationEpochSeconds = (
                expirationEpochSeconds or iso_to_epoch_seconds(expiration)
        )
        limitFeeRate = limitFeeRate or limitFee
        accountId = accountId or self.account.get('positionId')
        if not accountId:
            raise Exception(
                'No accountId provided' +
                'please call get_account()'
            )

        if not self.config:
            raise Exception(
                'No config provided' +
                'please call configs()'
            )
        symbolData = {}
        currency = {}
        for k, v in enumerate(self.config.get('perpetualContract')):
            if v.get('symbol') == symbol:
                symbolData = v
        for k, v2 in enumerate(self.config.get('currency')):
            if v2.get('id') == symbolData.get('settleCurrencyId'):
                currency = v2

        if symbolData is not None :
            number = decimal.Decimal(price) / decimal.Decimal(symbolData.get('tickSize'))
            if number > int(number):
                raise Exception(
                    'the price must Multiple of tickSize'
                )

        order_to_sign = SignableOrder(
            position_id=accountId,
            client_id=clientId,
            market=symbol,
            side=side,
            human_size=size,
            human_price=price,
            limit_fee=limitFeeRate,
            expiration_epoch_seconds=expirationEpochSeconds,
            synthetic_resolution=symbolData.get('starkExResolution'),
            synthetic_id=symbolData.get('starkExSyntheticAssetId'),
            collateral_id=currency.get('starkExAssetId'),
        )
        signature = order_to_sign.sign(self.stark_private_key)

        if side == ORDER_SIDE_BUY:
            human_cost = DECIMAL_CONTEXT_ROUND_UP.multiply(
                decimal.Decimal(size),
                decimal.Decimal(price)
            )
            fee = DECIMAL_CONTEXT_ROUND_UP.multiply(human_cost, decimal.Decimal(limitFeeRate))
        else:
            human_cost = DECIMAL_CONTEXT_ROUND_DOWN.multiply(
                decimal.Decimal(size),
                decimal.Decimal(price)
            )
            fee = DECIMAL_CONTEXT_ROUND_DOWN.multiply(human_cost, decimal.Decimal(limitFeeRate))

        limit_fee_rounded = DECIMAL_CONTEXT_ROUND_UP.quantize(
            decimal.Decimal(fee),
            decimal.Decimal(currency.get('stepSize')), )
        expirationEpoch = math.ceil(
            float(expirationEpochSeconds) / ONE_HOUR_IN_SECONDS,
        ) + ORDER_SIGNATURE_EXPIRATION_BUFFER_HOURS

        sl_limit_fee_rounded = None
        slSignature = None
        slTriggerPriceType = None
        slExpiration = None
        tp_limit_fee_rounded = None
        tpSignature = None
        tpTriggerPriceType = None
        tpExpiration = None

        if isOpenTpslOrder == True:
            if isSetOpenSl == True:
                slTriggerPriceType = triggerPriceType
                slExpiration = expirationEpoch * 3600 * 1000
                slClientId = slClientId or random_client_id()
                slOrder_to_sign = SignableOrder(
                    position_id=accountId,
                    client_id=slClientId,
                    market=symbol,
                    side=slSide,
                    human_size=slSize,
                    human_price=slPrice,
                    limit_fee=limitFeeRate,
                    expiration_epoch_seconds=expirationEpochSeconds,
                    synthetic_resolution=symbolData.get('starkExResolution'),
                    synthetic_id=symbolData.get('starkExSyntheticAssetId'),
                    collateral_id=currency.get('starkExAssetId'),
                )
                slSignature = slOrder_to_sign.sign(self.stark_private_key)

                if slSide == ORDER_SIDE_BUY:
                    slHuman_cost = DECIMAL_CONTEXT_ROUND_UP.multiply(
                    decimal.Decimal(slSize),
                    decimal.Decimal(slPrice)
                    )
                    slFee = DECIMAL_CONTEXT_ROUND_UP.multiply(slHuman_cost, decimal.Decimal(limitFeeRate))
                else:
                    slHuman_cost = DECIMAL_CONTEXT_ROUND_DOWN.multiply(
                        decimal.Decimal(slSize),
                        decimal.Decimal(slPrice)
                    )
                    slFee = DECIMAL_CONTEXT_ROUND_DOWN.multiply(slHuman_cost, decimal.Decimal(limitFeeRate))

                sl_limit_fee_rounded = DECIMAL_CONTEXT_ROUND_UP.quantize(
                    decimal.Decimal(slFee),
                    decimal.Decimal(currency.get('stepSize')), )

            if isSetOpenTp == True:
                tpTriggerPriceType = triggerPriceType
                tpExpiration = expirationEpoch * 3600 * 1000
                tpClientId = tpClientId or random_client_id()
                tpOrder_to_sign = SignableOrder(
                    position_id=accountId,
                    client_id=tpClientId,
                    market=symbol,
                    side=tpSide,
                    human_size=tpSize,
                    human_price=tpPrice,
                    limit_fee=limitFeeRate,
                    expiration_epoch_seconds=expirationEpochSeconds,
                    synthetic_resolution=symbolData.get('starkExResolution'),
                    synthetic_id=symbolData.get('starkExSyntheticAssetId'),
                    collateral_id=currency.get('starkExAssetId'),
                )
                tpSignature = tpOrder_to_sign.sign(self.stark_private_key)

                if tpSide == ORDER_SIDE_BUY:
                    tpHuman_cost = DECIMAL_CONTEXT_ROUND_UP.multiply(
                        decimal.Decimal(tpSize),
                        decimal.Decimal(tpPrice)
                    )
                    tpFee = DECIMAL_CONTEXT_ROUND_UP.multiply(tpHuman_cost, decimal.Decimal(limitFeeRate))
                else:
                    tpHuman_cost = DECIMAL_CONTEXT_ROUND_DOWN.multiply(
                        decimal.Decimal(tpSize),
                        decimal.Decimal(tpPrice)
                    )
                    tpFee = DECIMAL_CONTEXT_ROUND_DOWN.multiply(tpHuman_cost, decimal.Decimal(limitFeeRate))

                tp_limit_fee_rounded = DECIMAL_CONTEXT_ROUND_UP.quantize(
                    decimal.Decimal(tpFee),
                    decimal.Decimal(currency.get('stepSize')), )

        order = {
            'symbol': symbol,
            'side': side,
            'type': type,
            'timeInForce': timeInForce,
            'size': size,
            'price': price,
            'limitFee': str(limit_fee_rounded),
            'expiration': expirationEpoch * 3600 * 1000,
            'triggerPrice': triggerPrice,
            'triggerPriceType': triggerPriceType,
            'trailingPercent': trailingPercent,
            'clientId': clientId,
            'signature': signature,
            'reduceOnly': reduceOnly,
            'isPositionTpsl': isPositionTpsl,
            'isOpenTpslOrder': isOpenTpslOrder,
            'isSetOpenSl': isSetOpenSl,
            'isSetOpenTp': isSetOpenTp,
            'slClientOrderId': slClientId,
            'slPrice': slPrice,
            'slSide': slSide,
            'slSize': slSize,
            'slTriggerPrice': slTriggerPrice,
            'slTriggerPriceType': slTriggerPriceType,
            'slExpiration': slExpiration,
            'slLimitFee': str(sl_limit_fee_rounded),
            'slSignature': slSignature,
            'tpClientOrderId': tpClientId,
            'tpPrice': tpPrice,
            'tpSide': tpSide,
            'tpSize': tpSize,
            'tpTriggerPrice': tpTriggerPrice,
            'tpTriggerPriceType': tpTriggerPriceType,
            'tpExpiration': tpExpiration,
            'tpLimitFee': str(tp_limit_fee_rounded),
            'tpSignature': tpSignature,
            'sourceFlag': sourceFlag,
            'brokerId':brokerId,
        }

        path = URL_SUFFIX + "/v1/create-order"
        return self._post(
            endpoint=path,
            data=order
        )

    def create_order_v2(self,
                     symbol,
                     side,
                     type,
                     size,
                     limitFeeRate=None,
                     limitFee=None,
                     price=None,
                     accountId=None,
                     timeInForce="GOOD_TIL_CANCEL",
                     reduceOnly=False,
                     triggerPrice=None,
                     triggerPriceType=None,
                     trailingPercent=None,
                     clientId=None,
                     expiration=None,
                     expirationEpochSeconds=None,
                     isPositionTpsl = False,
                     signature=None,
                     isOpenTpslOrder=False,
                     isSetOpenSl=False,
                     isSetOpenTp=False,
                     slClientId=None,
                     slPrice=None,
                     slSide=None,
                     slSize=None,
                     slTriggerPrice=None,
                     tpClientId=None,
                     tpPrice=None,
                     tpSide=None,
                     tpSize=None,
                     tpTriggerPrice=None,
                     sourceFlag=None,
                     brokerId=None,):
        """"
        POST  create_order.
        client.create_order(symbol="BTC-USDC", side="SELL",
                                           type="LIMIT", size="0.01",
                                           price="20000", limitFeeRate="1",
                                            accountId="325881046451093849",reduceOnly=False,
                                           expiration=now_iso + SEVEN_DAYS_S + 60*1000, timeInForce="GOOD_TIL_CANCEL")

       :returns: Request results as dictionary.
       """
        price = str(price)
        size = str(size)
        clientId = clientId or random_client_id()
        if not self.stark_private_key:
            raise Exception(
                'No signature provided and client was not ' +
                'initialized with stark_private_key'
            )

        if bool(expiration) == bool(expirationEpochSeconds):
            raise ValueError(
                'Exactly one of expiration and expiration_epoch_seconds must '
                'be specified',
            )
        expiration = expiration or epoch_seconds_to_iso(
            expirationEpochSeconds,
        )
        expirationEpochSeconds = (
                expirationEpochSeconds or iso_to_epoch_seconds(expiration)
        )
        limitFeeRate = limitFeeRate or limitFee
        accountId = accountId or self.account.get('positionId')
        if not accountId:
            raise Exception(
                'No accountId provided' +
                'please call get_account_v2()'
            )

        if not self.configV2:
            raise Exception(
                'No config provided' +
                'please call configs_v2()'
            )
        symbolData = {}
        currency = {}
        config = {}
        if symbol.__contains__("USDT"):
            config = self.usdtConfigV2
        elif symbol.__contains__("USDC"):
            config = self.usdcConfigV2
        for k, v in enumerate(config.get('perpetualContract')):
            if v.get('symbol') == symbol:
                symbolData = v
        for k, v2 in enumerate(config.get('currency')):
            if v2.get('id') == symbolData.get('settleCurrencyId'):
                currency = v2

        if symbolData is not None :
            number = decimal.Decimal(price) / decimal.Decimal(symbolData.get('tickSize'))
            if number > int(number):
                raise Exception(
                    'the price must Multiple of tickSize'
                )

        order_to_sign = SignableOrder(
            position_id=accountId,
            client_id=clientId,
            market=symbol,
            side=side,
            human_size=size,
            human_price=price,
            limit_fee=limitFeeRate,
            expiration_epoch_seconds=expirationEpochSeconds,
            synthetic_resolution=symbolData.get('starkExResolution'),
            synthetic_id=symbolData.get('starkExSyntheticAssetId'),
            collateral_id=currency.get('starkExAssetId'),
        )
        signature = order_to_sign.sign(self.stark_private_key)

        if side == ORDER_SIDE_BUY:
            human_cost = DECIMAL_CONTEXT_ROUND_UP.multiply(
                decimal.Decimal(size),
                decimal.Decimal(price)
            )
            fee = DECIMAL_CONTEXT_ROUND_UP.multiply(human_cost, decimal.Decimal(limitFeeRate))
        else:
            human_cost = DECIMAL_CONTEXT_ROUND_DOWN.multiply(
                decimal.Decimal(size),
                decimal.Decimal(price)
            )
            fee = DECIMAL_CONTEXT_ROUND_DOWN.multiply(human_cost, decimal.Decimal(limitFeeRate))

        limit_fee_rounded = DECIMAL_CONTEXT_ROUND_UP.quantize(
            decimal.Decimal(fee),
            decimal.Decimal(currency.get('stepSize')), )
        expirationEpoch = math.ceil(
            float(expirationEpochSeconds) / ONE_HOUR_IN_SECONDS,
            ) + ORDER_SIGNATURE_EXPIRATION_BUFFER_HOURS

        sl_limit_fee_rounded = None
        slSignature = None
        slTriggerPriceType = None
        slExpiration = None
        tp_limit_fee_rounded = None
        tpSignature = None
        tpTriggerPriceType = None
        tpExpiration = None

        if isOpenTpslOrder == True:
            if isSetOpenSl == True:
                slTriggerPriceType = triggerPriceType
                slExpiration = expirationEpoch * 3600 * 1000
                slClientId = slClientId or random_client_id()
                slOrder_to_sign = SignableOrder(
                    position_id=accountId,
                    client_id=slClientId,
                    market=symbol,
                    side=slSide,
                    human_size=slSize,
                    human_price=slPrice,
                    limit_fee=limitFeeRate,
                    expiration_epoch_seconds=expirationEpochSeconds,
                    synthetic_resolution=symbolData.get('starkExResolution'),
                    synthetic_id=symbolData.get('starkExSyntheticAssetId'),
                    collateral_id=currency.get('starkExAssetId'),
                )
                slSignature = slOrder_to_sign.sign(self.stark_private_key)

                if slSide == ORDER_SIDE_BUY:
                    slHuman_cost = DECIMAL_CONTEXT_ROUND_UP.multiply(
                        decimal.Decimal(slSize),
                        decimal.Decimal(slPrice)
                    )
                    slFee = DECIMAL_CONTEXT_ROUND_UP.multiply(slHuman_cost, decimal.Decimal(limitFeeRate))
                else:
                    slHuman_cost = DECIMAL_CONTEXT_ROUND_DOWN.multiply(
                        decimal.Decimal(slSize),
                        decimal.Decimal(slPrice)
                    )
                    slFee = DECIMAL_CONTEXT_ROUND_DOWN.multiply(slHuman_cost, decimal.Decimal(limitFeeRate))

                sl_limit_fee_rounded = DECIMAL_CONTEXT_ROUND_UP.quantize(
                    decimal.Decimal(slFee),
                    decimal.Decimal(currency.get('stepSize')), )

            if isSetOpenTp == True:
                tpTriggerPriceType = triggerPriceType
                tpExpiration = expirationEpoch * 3600 * 1000
                tpClientId = tpClientId or random_client_id()
                tpOrder_to_sign = SignableOrder(
                    position_id=accountId,
                    client_id=tpClientId,
                    market=symbol,
                    side=tpSide,
                    human_size=tpSize,
                    human_price=tpPrice,
                    limit_fee=limitFeeRate,
                    expiration_epoch_seconds=expirationEpochSeconds,
                    synthetic_resolution=symbolData.get('starkExResolution'),
                    synthetic_id=symbolData.get('starkExSyntheticAssetId'),
                    collateral_id=currency.get('starkExAssetId'),
                )
                tpSignature = tpOrder_to_sign.sign(self.stark_private_key)

                if tpSide == ORDER_SIDE_BUY:
                    tpHuman_cost = DECIMAL_CONTEXT_ROUND_UP.multiply(
                        decimal.Decimal(tpSize),
                        decimal.Decimal(tpPrice)
                    )
                    tpFee = DECIMAL_CONTEXT_ROUND_UP.multiply(tpHuman_cost, decimal.Decimal(limitFeeRate))
                else:
                    tpHuman_cost = DECIMAL_CONTEXT_ROUND_DOWN.multiply(
                        decimal.Decimal(tpSize),
                        decimal.Decimal(tpPrice)
                    )
                    tpFee = DECIMAL_CONTEXT_ROUND_DOWN.multiply(tpHuman_cost, decimal.Decimal(limitFeeRate))

                tp_limit_fee_rounded = DECIMAL_CONTEXT_ROUND_UP.quantize(
                    decimal.Decimal(tpFee),
                    decimal.Decimal(currency.get('stepSize')), )

        order = {
            'symbol': symbol,
            'side': side,
            'type': type,
            'timeInForce': timeInForce,
            'size': size,
            'price': price,
            'limitFee': str(limit_fee_rounded),
            'expiration': expirationEpoch * 3600 * 1000,
            'triggerPrice': triggerPrice,
            'triggerPriceType': triggerPriceType,
            'trailingPercent': trailingPercent,
            'clientId': clientId,
            'signature': signature,
            'reduceOnly': reduceOnly,
            'isPositionTpsl': isPositionTpsl,
            'isOpenTpslOrder': isOpenTpslOrder,
            'isSetOpenSl': isSetOpenSl,
            'isSetOpenTp': isSetOpenTp,
            'slClientOrderId': slClientId,
            'slPrice': slPrice,
            'slSide': slSide,
            'slSize': slSize,
            'slTriggerPrice': slTriggerPrice,
            'slTriggerPriceType': slTriggerPriceType,
            'slExpiration': slExpiration,
            'slLimitFee': str(sl_limit_fee_rounded),
            'slSignature': slSignature,
            'tpClientOrderId': tpClientId,
            'tpPrice': tpPrice,
            'tpSide': tpSide,
            'tpSize': tpSize,
            'tpTriggerPrice': tpTriggerPrice,
            'tpTriggerPriceType': tpTriggerPriceType,
            'tpExpiration': tpExpiration,
            'tpLimitFee': str(tp_limit_fee_rounded),
            'tpSignature': tpSignature,
            'sourceFlag': sourceFlag,
            'brokerId':brokerId,
        }

        path = URL_SUFFIX + "/v2/create-order"
        return self._post(
            endpoint=path,
            data=order
        )

    def create_withdrawal(self,
                          amount,
                          asset,
                          accountId=None,
                          clientId=None,
                          expiration=None,
                          expirationEpochSeconds=None,
                          ethAddress=None,
                          signature=None, ):
        """"
        POST  create-withdrawal-to-address.
       :returns: Request results as dictionary.
       """

        clientId = clientId or random_client_id()
        if not self.stark_private_key:
            raise Exception(
                'No signature provided and client was not ' +
                'initialized with stark_private_key'
            )

        if bool(expiration) == bool(expirationEpochSeconds):
            raise ValueError(
                'Exactly one of expiration and expiration_epoch_seconds must '
                'be specified',
            )
        expiration = expiration or epoch_seconds_to_iso(
            expirationEpochSeconds,
        )
        expirationEpochSeconds = (
                expirationEpochSeconds or iso_to_epoch_seconds(expiration)
        )

        ethAddress = ethAddress or self.account.get('ethereumAddress')
        if not ethAddress:
            raise Exception(
                'No ethAddress provided' +
                'please call get_user()'
            )

        accountId = accountId or self.account.get('positionId')
        if not accountId:
            raise Exception(
                'No accountId provided' +
                'please call get_account()'
            )

        if not self.config:
            raise Exception(
                'No config provided' +
                'please call configs()'
            )

        currency = {}

        for k, v in enumerate(self.config.get('currency')):
            if v.get('id') == asset:
                currency = v
        withdraw_to_sign = SignableWithdrawal(
            network_id=self.network_id,
            position_id=accountId,
            client_id=clientId,
            human_amount=amount,
            expiration_epoch_seconds=expirationEpochSeconds,
            eth_address=ethAddress,
            collateral_id=currency.get('starkExAssetId'),
        )
        signature = withdraw_to_sign.sign(self.stark_private_key)

        expirationEpoch = math.ceil(
            float(expirationEpochSeconds) / ONE_HOUR_IN_SECONDS,
        ) + ORDER_SIGNATURE_EXPIRATION_BUFFER_HOURS

        withdraw = {
            'amount': amount,
            'asset': asset,
            'expiration': expirationEpoch * 3600 * 1000,
            'ethAddress': ethAddress,
            'clientId': clientId,
            'signature': signature,
        }

        path = URL_SUFFIX + "/v1/create-withdrawal-to-address"
        return self._post(
            endpoint=path,
            data=withdraw
        )

    def create_withdrawal_v2(self,
                          amount,
                          asset,
                          accountId=None,
                          clientId=None,
                          expiration=None,
                          expirationEpochSeconds=None,
                          ethAddress=None,
                          signature=None, ):
        """"
        POST  create-withdrawal-to-address.
       :returns: Request results as dictionary.
       """

        clientId = clientId or random_client_id()
        if not self.stark_private_key:
            raise Exception(
                'No signature provided and client was not ' +
                'initialized with stark_private_key'
            )

        if bool(expiration) == bool(expirationEpochSeconds):
            raise ValueError(
                'Exactly one of expiration and expiration_epoch_seconds must '
                'be specified',
            )
        expiration = expiration or epoch_seconds_to_iso(
            expirationEpochSeconds,
        )
        expirationEpochSeconds = (
                expirationEpochSeconds or iso_to_epoch_seconds(expiration)
        )

        ethAddress = ethAddress or self.account.get('ethereumAddress')
        if not ethAddress:
            raise Exception(
                'No ethAddress provided' +
                'please call get_user()'
            )

        accountId = accountId or self.account.get('positionId')
        if not accountId:
            raise Exception(
                'No accountId provided' +
                'please call get_account()'
            )

        currency = {}
        config = {}
        if asset.__contains__("USDT"):
            config = self.usdtConfigV2
        elif asset.__contains__("USDC"):
            config = self.usdcConfigV2


        for k, v in enumerate(config.get('currency')):
            if v.get('id') == asset:
                currency = v
        withdraw_to_sign = SignableWithdrawal(
            network_id=self.network_id,
            position_id=accountId,
            client_id=clientId,
            human_amount=amount,
            expiration_epoch_seconds=expirationEpochSeconds,
            eth_address=ethAddress,
            collateral_id=currency.get('starkExAssetId'),
        )
        signature = withdraw_to_sign.sign(self.stark_private_key)

        expirationEpoch = math.ceil(
            float(expirationEpochSeconds) / ONE_HOUR_IN_SECONDS,
            ) + ORDER_SIGNATURE_EXPIRATION_BUFFER_HOURS

        withdraw = {
            'amount': amount,
            'asset': asset,
            'expiration': expirationEpoch * 3600 * 1000,
            'ethAddress': ethAddress,
            'clientId': clientId,
            'signature': signature,
        }

        path = URL_SUFFIX + "/v2/create-withdrawal-to-address"
        return self._post(
            endpoint=path,
            data=withdraw
        )

    def fast_withdrawal(self,
                        amount,
                        asset,
                        accountId=None,
                        clientId=None,
                        expiration=None,
                        expirationEpochSeconds=None,
                        ethAddress=None,
                        erc20Address=None,
                        fee=None,
                        lpAccountId=None,
                        signature=None, ):
        """"
        POST  fast_withdrawal.
       :returns: Request results as dictionary.
       """

        clientId = clientId or random_client_id()
        if not self.stark_private_key:
            raise Exception(
                'No signature provided and client was not ' +
                'initialized with stark_private_key'
            )

        if bool(expiration) == bool(expirationEpochSeconds):
            raise ValueError(
                'Exactly one of expiration and expiration_epoch_seconds must '
                'be specified',
            )
        expiration = expiration or epoch_seconds_to_iso(
            expirationEpochSeconds,
        )
        expirationEpochSeconds = (
                expirationEpochSeconds or iso_to_epoch_seconds(expiration)
        )

        accountId = accountId or self.account.get('positionId')
        if not accountId:
            raise Exception(
                'No accountId provided' +
                'please call get_account()'
            )

        ethAddress = ethAddress or self.user.get('ethereumAddress') or self.account.get('ethereumAddress')
        if not ethAddress:
            raise Exception(
                'No ethAddress provided' +
                'please call get_user()'
            )

        if not self.config:
            raise Exception(
                'No config provided' +
                'please call configs()'
            )

        currency = {}
        for k, v in enumerate(self.config.get('currency')):
            if v.get('id') == asset:
                currency = v

        token = {}
        for k, v1 in enumerate(self.config.get('multiChain').get('chains')):
            if v1.get('chainId') == self.network_id:
                for _, v2 in enumerate(v1.get('tokens')):
                    if v2.get('token') == asset:
                        if v2.get('withdrawEnable') == True:
                            token = v2

        fact = get_transfer_erc20_fact(
            recipient=ethAddress,
            token_decimals=token.get('decimals'),
            human_amount=amount,
            token_address=(
                token.get('tokenAddress')
            ),
            salt=nonce_from_client_id(clientId),
        )

        totalAmount = decimal.Decimal(amount) + decimal.Decimal(fee)
        transfer_to_sign = SignableConditionalTransfer(
            network_id=self.network_id,
            sender_position_id=accountId,
            receiver_position_id=self.config.get('global').get('fastWithdrawAccountId'),
            receiver_public_key=self.config.get('global').get('fastWithdrawL2Key'),
            fact_registry_address=self.config.get('global').get('fastWithdrawFactRegisterAddress'),
            fact=fact,
            human_amount=str(totalAmount),
            client_id=clientId,
            expiration_epoch_seconds=expirationEpochSeconds,
            collateral_id=currency.get('starkExAssetId')
        )

        signature = transfer_to_sign.sign(self.stark_private_key)

        expirationEpoch = math.ceil(
            float(expirationEpochSeconds) / ONE_HOUR_IN_SECONDS,
        ) + ORDER_SIGNATURE_EXPIRATION_BUFFER_HOURS

        withdraw = {
            'amount': amount,
            'asset': asset,
            'expiration': expirationEpoch * 3600 * 1000,
            'ethAddress': ethAddress,
            'clientId': clientId,
            'signature': signature,
            'erc20Address': token.get('tokenAddress'),
            'fee': fee,
            'lpAccountId': self.config.get('global').get('fastWithdrawAccountId'),
            'chainId': self.network_id
        }

        path = URL_SUFFIX + "/v1/fast-withdraw"
        return self._post(
            endpoint=path,
            data=withdraw
        )

    def fast_withdrawal_v2(self,
                        amount,
                        asset,
                        accountId=None,
                        clientId=None,
                        expiration=None,
                        expirationEpochSeconds=None,
                        ethAddress=None,
                        erc20Address=None,
                        fee=None,
                        lpAccountId=None,
                        signature=None, ):
        """"
        POST  fast_withdrawal.
       :returns: Request results as dictionary.
       """

        clientId = clientId or random_client_id()
        if not self.stark_private_key:
            raise Exception(
                'No signature provided and client was not ' +
                'initialized with stark_private_key'
            )

        if bool(expiration) == bool(expirationEpochSeconds):
            raise ValueError(
                'Exactly one of expiration and expiration_epoch_seconds must '
                'be specified',
            )
        expiration = expiration or epoch_seconds_to_iso(
            expirationEpochSeconds,
        )
        expirationEpochSeconds = (
                expirationEpochSeconds or iso_to_epoch_seconds(expiration)
        )

        accountId = accountId or self.account.get('positionId')
        if not accountId:
            raise Exception(
                'No accountId provided' +
                'please call get_account()'
            )

        ethAddress = ethAddress or self.user.get('ethereumAddress') or self.account.get('ethereumAddress')
        if not ethAddress:
            raise Exception(
                'No ethAddress provided' +
                'please call get_user()'
            )

        currency = {}
        config = {}
        if asset.__contains__("USDT"):
            config = self.usdtConfigV2
        elif asset.__contains__("USDC"):
            config = self.usdcConfigV2

        for k, v in enumerate(config.get('currency')):
            if v.get('id') == asset:
                currency = v

        token = {}
        for k, v1 in enumerate(config.get('multiChain').get('chains')):
            if v1.get('chainId') == self.network_id:
                for _, v2 in enumerate(v1.get('tokens')):
                    if v2.get('token') == asset:
                        if v2.get('withdrawEnable') == True:
                            token = v2

        fact = get_transfer_erc20_fact(
            recipient=ethAddress,
            token_decimals=token.get('decimals'),
            human_amount=amount,
            token_address=(
                token.get('tokenAddress')
            ),
            salt=nonce_from_client_id(clientId),
        )

        totalAmount = decimal.Decimal(amount) + decimal.Decimal(fee)
        transfer_to_sign = SignableConditionalTransfer(
            network_id=self.network_id,
            sender_position_id=accountId,
            receiver_position_id=config.get('global').get('fastWithdrawAccountId'),
            receiver_public_key=config.get('global').get('fastWithdrawL2Key'),
            fact_registry_address=config.get('global').get('fastWithdrawFactRegisterAddress'),
            fact=fact,
            human_amount=str(totalAmount),
            client_id=clientId,
            expiration_epoch_seconds=expirationEpochSeconds,
            collateral_id=currency.get('starkExAssetId')
        )

        signature = transfer_to_sign.sign(self.stark_private_key)

        expirationEpoch = math.ceil(
            float(expirationEpochSeconds) / ONE_HOUR_IN_SECONDS,
            ) + ORDER_SIGNATURE_EXPIRATION_BUFFER_HOURS

        withdraw = {
            'amount': amount,
            'asset': asset,
            'expiration': expirationEpoch * 3600 * 1000,
            'ethAddress': ethAddress,
            'clientId': clientId,
            'signature': signature,
            'erc20Address': token.get('tokenAddress'),
            'fee': fee,
            'lpAccountId': config.get('global').get('fastWithdrawAccountId'),
            'chainId': self.network_id
        }

        path = URL_SUFFIX + "/v2/fast-withdraw"
        return self._post(
            endpoint=path,
            data=withdraw
        )

    def cross_chain_withdraw(self,
                             amount,
                             asset,
                             chainId,
                             accountId=None,
                             clientId=None,
                             expiration=None,
                             expirationEpochSeconds=None,
                             erc20Address=None,
                             fee=None,
                             lpAccountId=None,
                             signature=None, ):
        """"
        POST  cross_chain_withdraw.
       :returns: Request results as dictionary.
       """
        clientId = clientId or random_client_id()
        if not self.stark_private_key:
            raise Exception(
                'No signature provided and client was not ' +
                'initialized with stark_private_key'
            )

        if bool(expiration) == bool(expirationEpochSeconds):
            raise ValueError(
                'Exactly one of expiration and expiration_epoch_seconds must '
                'be specified',
            )
        expiration = expiration or epoch_seconds_to_iso(
            expirationEpochSeconds,
        )
        expirationEpochSeconds = (
                expirationEpochSeconds or iso_to_epoch_seconds(expiration)
        )

        accountId = accountId or self.account.get('positionId')
        if not accountId:
            raise Exception(
                'No accountId provided' +
                'please call gett_account()'
            )

        if not self.config:
            raise Exception(
                'No config provided' +
                'please call configs()'
            )

        currency = {}
        for k, v in enumerate(self.config.get('currency')):
            if v.get('id') == asset:
                currency = v

        token = {}
        for k, v1 in enumerate(self.config.get('multiChain').get('chains')):
            if v1.get('chainId') == int(chainId):
                for _, v2 in enumerate(v1.get('tokens')):
                    if v2.get('token') == asset:
                        if v2.get('withdrawEnable') == True:
                            token = v2

        totalAmount = decimal.Decimal(amount) + decimal.Decimal(fee)
        transfer_to_sign = SignableTransfer(
            network_id=chainId,
            sender_position_id=accountId,
            receiver_position_id=self.config.get('global').get('crossChainAccountId'),
            receiver_public_key=self.config.get('global').get('crossChainL2Key'),
            human_amount=str(totalAmount),
            client_id=clientId,
            expiration_epoch_seconds=expirationEpochSeconds,
            collateral_id=currency.get('starkExAssetId')
        )
        signature = transfer_to_sign.sign(self.stark_private_key)

        expirationEpoch = math.ceil(
            float(expirationEpochSeconds) / ONE_HOUR_IN_SECONDS,
        ) + ORDER_SIGNATURE_EXPIRATION_BUFFER_HOURS

        withdraw = {
            'amount': amount,
            'asset': asset,
            'expiration': expirationEpoch * 3600 * 1000,
            'clientId': clientId,
            'signature': signature,
            'erc20Address': token.get('tokenAddress'),
            'fee': fee,
            'lpAccountId': self.config.get('global').get('crossChainAccountId'),
            'chainId': chainId
        }
        path = URL_SUFFIX + "/v1/cross-chain-withdraw"
        return self._post(
            endpoint=path,
            data=withdraw
        )

    def cross_chain_withdraw_v2(self,
                             amount,
                             asset,
                             chainId,
                             accountId=None,
                             clientId=None,
                             expiration=None,
                             expirationEpochSeconds=None,
                             erc20Address=None,
                             fee=None,
                             lpAccountId=None,
                             signature=None, ):
        """"
        POST  cross_chain_withdraw.
       :returns: Request results as dictionary.
       """
        clientId = clientId or random_client_id()
        if not self.stark_private_key:
            raise Exception(
                'No signature provided and client was not ' +
                'initialized with stark_private_key'
            )

        if bool(expiration) == bool(expirationEpochSeconds):
            raise ValueError(
                'Exactly one of expiration and expiration_epoch_seconds must '
                'be specified',
            )
        expiration = expiration or epoch_seconds_to_iso(
            expirationEpochSeconds,
        )
        expirationEpochSeconds = (
                expirationEpochSeconds or iso_to_epoch_seconds(expiration)
        )

        accountId = accountId or self.account.get('positionId')
        if not accountId:
            raise Exception(
                'No accountId provided' +
                'please call gett_account()'
            )

        currency = {}
        config = {}
        if asset.__contains__("USDT"):
            config = self.usdtConfigV2
        elif asset.__contains__("USDC"):
            config = self.usdcConfigV2

        for k, v in enumerate(config.get('currency')):
            if v.get('id') == asset:
                currency = v

        token = {}
        for k, v1 in enumerate(config.get('multiChain').get('chains')):
            if v1.get('chainId') == int(chainId):
                for _, v2 in enumerate(v1.get('tokens')):
                    if v2.get('token') == asset:
                        if v2.get('withdrawEnable') == True:
                            token = v2

        totalAmount = decimal.Decimal(amount) + decimal.Decimal(fee)
        transfer_to_sign = SignableTransfer(
            network_id=chainId,
            sender_position_id=accountId,
            receiver_position_id=config.get('global').get('crossChainAccountId'),
            receiver_public_key=config.get('global').get('crossChainL2Key'),
            human_amount=str(totalAmount),
            client_id=clientId,
            expiration_epoch_seconds=expirationEpochSeconds,
            collateral_id=currency.get('starkExAssetId')
        )
        signature = transfer_to_sign.sign(self.stark_private_key)

        expirationEpoch = math.ceil(
            float(expirationEpochSeconds) / ONE_HOUR_IN_SECONDS,
            ) + ORDER_SIGNATURE_EXPIRATION_BUFFER_HOURS

        withdraw = {
            'amount': amount,
            'asset': asset,
            'expiration': expirationEpoch * 3600 * 1000,
            'clientId': clientId,
            'signature': signature,
            'erc20Address': token.get('tokenAddress'),
            'fee': fee,
            'lpAccountId': config.get('global').get('crossChainAccountId'),
            'chainId': chainId
        }
        path = URL_SUFFIX + "/v2/cross-chain-withdraw"
        return self._post(
            endpoint=path,
            data=withdraw
        )



================================================
FILE: apexomni/http_private_v3.py
================================================
import hashlib
import json
import time
import urllib

from apexomni import zklink_sdk as sdk
from apexomni.constants import URL_SUFFIX, APEX_OMNI_HTTP_TEST
from apexomni.helpers.request_helpers import random_client_id
from apexomni.http_private import HttpPrivate


class HttpPrivate_v3(HttpPrivate):

    def generate_nonce_v3(self, l2Key, ethAddress, chainId,
                       refresh="false"
                       ):
        """"
        POST: Generate nonce.
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#privateapi-post-generate-nonce
        :returns: Request results as dictionary.
        """

        path = URL_SUFFIX + "/v3/generate-nonce"
        return self._private_request(
            method="POST",
            path=path,
            data={
                'l2Key': l2Key,
                'ethAddress': ethAddress,
                'chainId': chainId,
                'category': 'CATEGORY_API',
                'refresh': refresh,
            }
        )

    def register_user_v3(
            self,
            nonce,
            l2Key=None,
            seeds=None,
            ethereum_address=None,
            referred_by_affiliate_link=None,
            country=None,
            isLpAccount=None,
            eth_mul_address=None,
            sourceFlag=None,
    ):
        """"
        POST Registration & Onboarding.
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#privateapi-post-registration-amp-onboarding
        :returns: Request results as dictionary.
        """
        l2_key = l2Key or self.zk_l2Key
        l2_seeds = seeds or self.zk_seeds

        if l2_key is None:
            raise ValueError(
                'zk l2Key is required'
            )

        if l2_seeds is None:
            raise ValueError(
                'zk seeds is required'
            )

        eth_address = ethereum_address or self.default_address

        msg = str(l2_key.removeprefix('0x') + eth_address + nonce).lower()
        message = hashlib.sha256()
        message.update(msg.encode())  # Encode as UTF-8.
        msgHash = message.digest()


        EC_ORDER = '3618502788666131213697322783095070105526743751716087489154079457884512865583';

        bn1 = int(msgHash.hex(), 16)
        bn2 = int (EC_ORDER, 10)

        bn3 = hex(bn1)
        signMsg = hex(bn1.__mod__(bn2))

        seeds = bytes.fromhex(l2_seeds)
        signerSeed = sdk.ZkLinkSigner.new_from_seed(seeds)
        signatureOnboard = signerSeed.sign_musig(signMsg.removeprefix('0x').encode())

        apiKeyHash = hex(bn1).removeprefix('0x') + '|' + signMsg.removeprefix('0x')

        path = URL_SUFFIX + "/v3/new-onboarding"
        onboardingRes = self._private_request(
            method="POST",
            path=path,
            data= {
                'l2Key': l2_key,
                'referredByAffiliateLink': referred_by_affiliate_link,
                'ethereumAddress': eth_address,
                'country': country,
                'category': 'CATEGORY_API',
                'isLpAccount': isLpAccount,
                'ethMulAddress': eth_mul_address,
                'sourceFlag': sourceFlag,
                'apiKeyHash': apiKeyHash,
            },
            headers={
                'APEX-SIGNATURE': signatureOnboard.signature,
                'APEX-ETHEREUM-ADDRESS': eth_address,
            }
        )
        if onboardingRes.get('data') is not None:
            self.user = onboardingRes.get('data').get('user')
            self.accountV3 = onboardingRes.get('data').get('account')
            key = onboardingRes['data']['apiKey']['key']
            secret = onboardingRes['data']['apiKey']['secret']
            passphrase = onboardingRes['data']['apiKey']['passphrase']
            self.api_key_credentials = {'key': key,'secret': secret, 'passphrase': passphrase}
        return onboardingRes


    def derive_zk_key(
            self,
            ethereum_address=None,
    ):
        msgHeader = 'ApeX Omni Mainnet'
        if self.endpoint == APEX_OMNI_HTTP_TEST:
            msgHeader = 'ApeX Omni Testnet'
        signature = self.starkeySigner.sign_zk_message(
            ethereum_address or self.default_address,
            msgHeader,
            )

        seedstr = signature.removeprefix("0x")
        seeds = bytes.fromhex(seedstr)
        self.zk_seeds = seedstr
        signerSeed = sdk.ZkLinkSigner.new_from_seed(seeds)
        pubKey = signerSeed.public_key()
        self.zk_l2Key = pubKey
        pubKeyHash = sdk.get_public_key_hash(pubKey)

        return {
            'seeds': seedstr,
            'l2Key': pubKey,
            'pubKeyHash': pubKeyHash
        }

    def user_v3(self, **kwargs):
        """"
        GET Retrieve User Data.
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#privateapi-get-retrieve-user-data
        :returns: Request results as dictionary.
        """

        path = URL_SUFFIX + "/v3/user"
        userRes = self._get(
            endpoint=path,
            params=kwargs
        )
        self.user = userRes.get('data')
        return userRes

    def get_user_v3(self, **kwargs):
        """"
        GET Retrieve User Data.
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#privateapi-get-retrieve-user-data
        :returns: Request results as dictionary.
        """

        path = URL_SUFFIX + "/v3/user"
        userRes = self._get(
            endpoint=path,
            params=kwargs
        )
        self.user = userRes.get('data')
        return userRes


    def modify_user_v3(self, **kwargs):
        """"
        POST Edit User Data.
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#privateapi-post-edit-user-data
        :returns: Request results as dictionary.
        """

        path = URL_SUFFIX + "/v3/modify-user"

        return self._post(
            endpoint=path,
            data=kwargs
        )


    def get_account_v3(self, **kwargs):
        """"
        GET Retrieve User Account Data.
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#privateapi-get-retrieve-user-account-data
        :returns: Request results as dictionary.
        """

        path = URL_SUFFIX + "/v3/account"
        accountRes =  self._get(
            endpoint=path,
            params=kwargs
        )
        if accountRes.get('data') is not None:
            self.accountV3 = accountRes.get('data')
            self.default_address = self.accountV3.get('ethereumAddress')
        return accountRes.get('data')

    def transfers_v3(self, **kwargs):
        """"
        GET Retrieve User Deposit Data.
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#privateapi-get-retrieve-user-deposit-data
        :returns: Request results as dictionary.
        """

        kwargs.update(subAccountId='0')
        path = URL_SUFFIX + "/v3/transfers"
        return self._get(
            endpoint=path,
            params=kwargs
        )

    def transfer_v3(self, **kwargs):
        """"
        GET Retrieve User Deposit Data.
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#privateapi-get-retrieve-user-deposit-data
        :returns: Request results as dictionary.
        """

        path = URL_SUFFIX + "/v3/transfer"
        return self._get(
            endpoint=path,
            params=kwargs
        )

    def contract_transfers_v3(self, **kwargs):
        """"
        GET Retrieve User Deposit Data.
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#privateapi-get-retrieve-user-deposit-data
        :returns: Request results as dictionary.
        """

        path = URL_SUFFIX + "/v3/contract-transfers"
        return self._get(
            endpoint=path,
            params=kwargs
        )

    def contract_transfer_v3(self, **kwargs):
        """"
        GET Retrieve User Deposit Data.
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#privateapi-get-retrieve-user-deposit-data
        :returns: Request results as dictionary.
        """

        path = URL_SUFFIX + "/v3/contract-transfer"
        return self._get(
            endpoint=path,
            params=kwargs
        )

    def withdraw_list_v3(self, **kwargs):
        """"
        GET Retrieve User Withdrawal List.
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#privateapi-get-retrieve-user-withdrawal-list
        :returns: Request results as dictionary.
        """

        path = URL_SUFFIX + "/v3/withdraw-list"
        return self._get(
            endpoint=path,
            params=kwargs
        )


    def contract_transfer_limit_v3(self, **kwargs):
        """"
        GET Retrieve Withdrawal & Transfer Limits.
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#privateapi-get-retrieve-withdrawal-amp-transfer-limits
        :returns: Request results as dictionary.
        """

        path = URL_SUFFIX + "/v3/contract-transfer-limit"
        return self._get(
            endpoint=path,
            params=kwargs
        )


    def fills_v3(self, **kwargs):
        """"
        GET Retrieve Trade History.
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#privateapi-get-retrieve-trade-history
        :returns: Request results as dictionary.
        """

        path = URL_SUFFIX + "/v3/fills"
        return self._get(
            endpoint=path,
            params=kwargs
        )

    def order_fills_v3(self, **kwargs):

        path = URL_SUFFIX + "/v3/order-fills"
        return self._get(
            endpoint=path,
            params=kwargs
        )

    def delete_order_v3(self, **kwargs):
        """"
        POST Cancel Order.
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#privateapi-post-cancel-order
        :returns: Request results as dictionary.
        """

        path = URL_SUFFIX + "/v3/delete-order"
        return self._post(
            endpoint=path,
            data=kwargs
        )

    def delete_orders_v3(self, **kwargs):

        path = URL_SUFFIX + "/v3/delete-orders"
        return self._post(
            endpoint=path,
            data=kwargs
        )


    def delete_order_by_client_order_id_v3(self, **kwargs):
        """"
        POST Cancel Order.
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#privateapi-post-cancel-order
        :returns: Request results as dictionary.
        """

        path = URL_SUFFIX + "/v3/delete-client-order-id"
        return self._post(
            endpoint=path,
            data=kwargs
        )
    def delete_order_by_client_order_ids_v3(self, **kwargs):
        path = URL_SUFFIX + "/v3/delete-client-order-ids"
        return self._post(
            endpoint=path,
            data=kwargs
        )

    def delete_open_orders_v3(self, **kwargs):
        """"
        POST Cancel all Open Orders
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#privateapi-post-cancel-all-open-orders
        :returns: Request results as dictionary.
        """

        path = URL_SUFFIX + "/v3/delete-open-orders"
        return self._post(
            endpoint=path,
            data=kwargs
        )

    def open_orders_v3(self, **kwargs):
        """"
        GET Retrieve Open Orders.
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#privateapi-get-retrieve-open-orders
        :returns: Request results as dictionary.
        """

        path = URL_SUFFIX + "/v3/open-orders"
        return self._get(
            endpoint=path,
            params=kwargs
        )


    def history_orders_v3(self, **kwargs):
        """"
        GET Retrieve All Order History.
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#privateapi-get-retrieve-all-order-history
        :returns: Request results as dictionary.
        """

        path = URL_SUFFIX + "/v3/history-orders"
        return self._get(
            endpoint=path,
            params=kwargs
        )


    def get_order_v3(self, **kwargs):
        """"
        GET Retrieve Order ID.
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#privateapi-get-retrieve-order-id
        :returns: Request results as dictionary.
        """

        path = URL_SUFFIX + "/v3/order"
        return self._get(
            endpoint=path,
            params=kwargs
        )

    def get_order_by_client_order_id_v3(self, **kwargs):
        """"
        GET Retrieve Order ID.
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#privateapi-get-retrieve-order-id
        :returns: Request results as dictionary.
        """

        path = URL_SUFFIX + "/v3/order-by-client-order-id"
        return self._get(
            endpoint=path,
            params=kwargs
        )


    def funding_v3(self, **kwargs):
        """"
        GET Retrieve Funding Rate.
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#privateapi-get-retrieve-funding-rate
        :returns: Request results as dictionary.
        """

        path = URL_SUFFIX + "/v3/funding"
        return self._get(
            endpoint=path,
            params=kwargs
        )


    def historical_pnl_v3(self, **kwargs):
        """"
        GET Retrieve User Historial Profit and Loss.
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#privateapi-get-retrieve-user-historial-profit-and-loss
        :returns: Request results as dictionary.
        """

        path = URL_SUFFIX + "/v3/historical-pnl"
        return self._get(
            endpoint=path,
            params=kwargs
        )

    def yesterday_pnl_v3(self, **kwargs):
        """"
        GET Retrieve Yesterday's Profit & Loss.
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#privateapi-get-retrieve-yesterday-39-s-profit-amp-loss
        :returns: Request results as dictionary.
        """

        path = URL_SUFFIX + "/v3/yesterday-pnl"
        return self._get(
            endpoint=path,
            params=kwargs
        )

    def history_value_v3(self, **kwargs):
        """"
        GET Retrieve Historical Asset Value.
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#privateapi-get-retrieve-historical-asset-value
        :returns: Request results as dictionary.
        """

        path = URL_SUFFIX + "/v3/history-value"
        return self._get(
            endpoint=path,
            params=kwargs
        )


    def get_worst_price_v3(self, **kwargs):
        """"
        get market price from orderbook
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#privateapi-get-retrieve-worst-price
        :returns: Request results as dictionary.
        """

        path = URL_SUFFIX + "/v3/get-worst-price"
        return self._get(
            endpoint=path,
            params=kwargs
        )

    def get_order_by_client_id_v3(self, **kwargs):
        """"
        get market price from orderbook
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#privateapi-get-retrieve-worst-price
        :returns: Request results as dictionary.
        """

        path = URL_SUFFIX + "/v3/order-by-client-order-id"
        return self._get(
            endpoint=path,
            params=kwargs
        )

    def get_account_balance_v3(self, **kwargs):
        """"
        get market price from orderbook
        :param kwargs: See
        https://api-docs.pro.apex.exchange/?lang=zh-TW#privateapi-get-retrieve-user-account-balance
        :returns: Request results as dictionary.
        """

        path = URL_SUFFIX + "/v3/account-balance"
        return self._get(
            endpoint=path,
            params=kwargs
        )



    def set_initial_margin_rate_v3(self, **kwargs):
        """"
        get market price from orderbook
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#privateapi-post-sets-the-initial-margin-rate-of-a-contract
        :returns: Request results as dictionary.
        """

        path = URL_SUFFIX + "/v3/set-initial-margin-rate"
        return self._post(
            endpoint=path,
            data=kwargs
        )


    def change_pub_key_v3(self,
                          chainId,
                          zkAccountId,
                          seeds,
                          newPkHash,
                          nonce,
                          l2Key,
                          feeToken=None,
                          asset='USDT',
                          subAccountId='0',
                          fee='0',
                          ethPrivateKey = None,
                          ethSignatureType='EthECDSA',
                          signature=None,
                          ethSignature=None,
                          timestamp=None,):
        path = URL_SUFFIX + "/v3/change-pub-key"

        times = timestamp or int(time.time())

        #signer1 = sdk.ZkLinkSigner().new_from_hex_eth_signer(ethPrivateKey)
        #pubKey = signer1.public_key()
        #newPkHash = sdk.get_public_key_hash(pubKey)

        feeToken = feeToken or self.configV3.get('spotConfig').get('global').get('defaultChangePubKeyFeeTokenId')

        builder = sdk.ChangePubKeyBuilder(chainId, int(zkAccountId), int(subAccountId), newPkHash, int(feeToken), fee, int(nonce), ethSignature, int(times))
        tx = sdk.ChangePubKey(builder)


        seedsByte = bytes.fromhex(seeds.removeprefix('0x') )
        signerSeed = sdk.ZkLinkSigner.new_from_seed(seedsByte)
        auth_data = signerSeed.sign_musig(tx.get_bytes())
        signature = auth_data.signature
        if  ethSignatureType != 'Onchain' and ethPrivateKey is not None:
            signer = sdk.Signer(ethPrivateKey, sdk.L1SignerType.ETH())
            authSigner = json.loads(signer.sign_change_pubkey_with_eth_ecdsa_auth(tx).tx)
            ethSignature = authSigner.get('ethAuthData').get('ethSignature')

        print(builder)
        print(signature)

        return self._post(
            endpoint=path,
            data={
                'chainId': chainId,
                'zkAccountId': zkAccountId,
                'subAccountId' : subAccountId,
                'newPkHash': newPkHash,
                'feeToken': feeToken,
                'nonce':nonce,
                'l2Key': l2Key,
                'fee': fee,
                'ethSignatureType': ethSignatureType,
                'signature': signature,
                'ethSignature': ethSignature,
                'timestamp':times
            }
        )

    def withdraw_fee_v3(self, **kwargs):
        """"
        GET Fast & Cross-Chain Withdrawal Fees.
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#privateapi-get-fast-amp-cross-chain-withdrawal-fees
        :returns: Request results as dictionary.
        """

        path = URL_SUFFIX + "/v3/withdraw-fee"
        return self._get(
            endpoint=path,
            params=kwargs
        )

    def all_apikeys_v3(self, **kwargs):

        path = URL_SUFFIX + "/v3/all-api-keys"
        return self._get(
            endpoint=path,
            params=kwargs
        )

    def get_repayment_price_v3(self, repaymentPriceTokens, clientId=None ):

        repaymentPriceTokens = urllib.parse.quote(repaymentPriceTokens)

        clientId = clientId or random_client_id()
        path = URL_SUFFIX + "/v3/repayment-price"
        return self._get(
            endpoint=path,
            params={
                'repaymentPriceTokens':repaymentPriceTokens,
                'clientId': clientId
            }
        )

    def apikey_bind_ip_v3(self, **kwargs):

        path = URL_SUFFIX + "/v3/bind-ip"
        return self._post(
            endpoint=path,
            data=kwargs
        )

    def delete_api_key_v3(self, **kwargs):

        path = URL_SUFFIX + "/v3/delete-api-key"
        return self._post(
            endpoint=path,
            data=kwargs
        )

    def generate_api_key_v3(self, nonce,
                            ips, remark
                            ):
        l2_key = self.zk_l2Key
        l2_seeds = self.zk_seeds

        if l2_key is None:
            raise ValueError(
                'zk l2Key is required'
            )

        if l2_seeds is None:
            raise ValueError(
                'zk seeds is required'
            )

        eth_address =  self.default_address

        msg = str(l2_key.removeprefix('0x') + eth_address + nonce).lower()
        message = hashlib.sha256()
        message.update(msg.encode())  # Encode as UTF-8.
        msgHash = message.digest()


        EC_ORDER = '3618502788666131213697322783095070105526743751716087489154079457884512865583';

        bn1 = int(msgHash.hex(), 16)
        bn2 = int (EC_ORDER, 10)

        bn3 = hex(bn1)
        signMsg = hex(bn1.__mod__(bn2))

        seeds = bytes.fromhex(l2_seeds)
        signerSeed = sdk.ZkLinkSigner.new_from_seed(seeds)
        signatureOnboard = signerSeed.sign_musig(signMsg.removeprefix('0x').encode())

        path = URL_SUFFIX + "/v3/generate-api-key"
        return self._post(
            endpoint=path,
            data={
                'signature':signatureOnboard.signature,
                'l2Key':l2_key,
                'ips':ips,
                'remark':remark,
            }
        )

    def withdraws_by_time_and_status_v3(self, **kwargs):
        path = URL_SUFFIX + "/v3/withdraws-by-time-and-status"
        return self._get(
            endpoint=path,
            params=kwargs
        )



================================================
FILE: apexomni/http_public.py
================================================
from apexomni import HTTP
from apexomni.constants import URL_SUFFIX


class HttpPublic(HTTP):
    def server_time(self, **kwargs):
        """"
        GET Retrieve System Time.
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#publicapi-get-apex-server-time
        :returns: Request results as dictionary.
        """

        suffix = URL_SUFFIX + "/v1/time"
        return self._submit_request(
            method="GET",
            path=self.endpoint + suffix
        )

    def depth(self, **kwargs):
        """"
        GET Retrieve Market Depth.
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#publicapi-get-retrieve-market-depth
        :returns: Request results as dictionary.
        """
        suffix = URL_SUFFIX + "/v1/depth"
        if kwargs.get('symbol') is not None:
            kwargs['symbol'] = kwargs['symbol'].replace('-', '')
        return self._submit_request(
            method='GET',
            path=self.endpoint + suffix,
            query=kwargs
        )

    def trades(self, **kwargs):
        """"
        GET Retrieve Newest Trading Data.
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#publicapi-get-retrieve-newest-trading-data
        :returns: Request results as dictionary.
        """
        suffix = URL_SUFFIX + "/v1/trades"
        if kwargs.get('symbol') is not None:
            kwargs['symbol'] = kwargs['symbol'].replace('-', '')
        return self._submit_request(
            method='GET',
            path=self.endpoint + suffix,
            query=kwargs
        )

    def klines(self, **kwargs):
        """"
        GET Retrieve Candlestick Chart Data.
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#publicapi-get-retrieve-candlestick-chart-data
        :returns: Request results as dictionary.
        """
        suffix = URL_SUFFIX + "/v1/klines"
        if kwargs.get('symbol') is not None:
            kwargs['symbol'] = kwargs['symbol'].replace('-', '')
        return self._submit_request(
            method='GET',
            path=self.endpoint + suffix,
            query=kwargs
        )

    def ticker(self, **kwargs):
        """"
        GET Retrieve Ticker Data.
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#publicapi-get-retrieve-ticker-data
        :returns: Request results as dictionary.
        """
        suffix = URL_SUFFIX + "/v1/ticker"
        if kwargs.get('symbol') is not None:
            kwargs['symbol'] = kwargs['symbol'].replace('-', '')
        return self._submit_request(
            method='GET',
            path=self.endpoint + suffix,
            query=kwargs
        )

    def history_funding(self, **kwargs):
        """"
        GET Retrieve Funding Rate History.
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#publicapi-get-retrieve-funding-rate-history
        :returns: Request results as dictionary.
        """
        suffix = URL_SUFFIX + "/v1/history-funding"
        #if kwargs['symbol'] is not None:
        #    kwargs['symbol'] = kwargs['symbol'].replace('-', '')
        return self._submit_request(
            method='GET',
            path=self.endpoint + suffix,
            query=kwargs
        )

    def history_funding_v2(self, **kwargs):
        """"
        GET Retrieve Funding Rate History.
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#publicapi-get-retrieve-funding-rate-history
        :returns: Request results as dictionary.
        """
        suffix = URL_SUFFIX + "/v2/history-funding"
        #if kwargs.get('symbol') is not None:
        #    kwargs['symbol'] = kwargs['symbol'].replace('-', '')
        return self._submit_request(
            method='GET',
            path=self.endpoint + suffix,
            query=kwargs
        )

    def test_ticker(self, **kwargs):
        suffix = URL_SUFFIX + "/v1/test-ticker"
        if kwargs.get('symbol') is not None:
            kwargs['symbol'] = kwargs['symbol'].replace('-', '')
        return self._submit_request(
            method='GET',
            path=self.endpoint + suffix,
            query=kwargs
        )

    def depth_v3(self, **kwargs):
        """"
        GET Retrieve Market Depth.
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#publicapi-get-retrieve-market-depth
        :returns: Request results as dictionary.
        """
        suffix = URL_SUFFIX + "/v3/depth"
        if kwargs.get('symbol') is not None:
            kwargs['symbol'] = kwargs['symbol'].replace('-', '')
        return self._submit_request(
            method='GET',
            path=self.endpoint + suffix,
            query=kwargs
        )

    def trades_v3(self, **kwargs):
        """"
        GET Retrieve Newest Trading Data.
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#publicapi-get-retrieve-newest-trading-data
        :returns: Request results as dictionary.
        """
        suffix = URL_SUFFIX + "/v3/trades"
        if kwargs.get('symbol') is not None:
            kwargs['symbol'] = kwargs['symbol'].replace('-', '')
        return self._submit_request(
            method='GET',
            path=self.endpoint + suffix,
            query=kwargs
        )

    def klines_v3(self, **kwargs):
        """"
        GET Retrieve Candlestick Chart Data.
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#publicapi-get-retrieve-candlestick-chart-data
        :returns: Request results as dictionary.
        """
        suffix = URL_SUFFIX + "/v3/klines"
        if kwargs.get('symbol') is not None:
            kwargs['symbol'] = kwargs['symbol'].replace('-', '')
        return self._submit_request(
            method='GET',
            path=self.endpoint + suffix,
            query=kwargs
        )

    def ticker_v3(self, **kwargs):
        """"
        GET Retrieve Ticker Data.
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#publicapi-get-retrieve-ticker-data
        :returns: Request results as dictionary.
        """
        suffix = URL_SUFFIX + "/v3/ticker"
        if kwargs.get('symbol') is not None:
            kwargs['symbol'] = kwargs['symbol'].replace('-', '')
        return self._submit_request(
            method='GET',
            path=self.endpoint + suffix,
            query=kwargs
        )

    def history_funding_v3(self, **kwargs):
        """"
        GET Retrieve Funding Rate History.
        :param kwargs: See
        https://api-docs.pro.apex.exchange/#publicapi-get-retrieve-funding-rate-history
        :returns: Request results as dictionary.
        """
        suffix = URL_SUFFIX + "/v3/history-funding"
        return self._submit_request(
            method='GET',
            path=self.endpoint + suffix,
            query=kwargs
        )



================================================
FILE: apexomni/models.py
================================================
from collections import namedtuple


def configDecoder(configs):
    return namedtuple('X', configs.keys())(*configs.values())

class CreateOrderModel:
    def __init__(self, symbol,
                 side,
                 type,
                 size,
                 subAccountId=None,
                 takerFeeRate=None,
                 makerFeeRate=None,
                 price=None,
                 accountId=None,
                 timeInForce="GOOD_TIL_CANCEL",
                 reduceOnly=False,
                 triggerPrice=None,
                 triggerPriceType=None,
                 trailingPercent=None,
                 clientId=None,
                 timestampSeconds=None,
                 isPositionTpsl = False,
                 signature=None,
                 isOpenTpslOrder=False,
                 isSetOpenSl=False,
                 isSetOpenTp=False,
                 slClientId=None,
                 slPrice=None,
                 slSide=None,
                 slSize=None,
                 slTriggerPrice=None,
                 tpClientId=None,
                 tpPrice=None,
                 tpSide=None,
                 tpSize=None,
                 tpTriggerPrice=None,
                 sourceFlag=None,
                 brokerId=None,):
        self.symbol = symbol
        self.side = side
        self.type = type
        self.size = size
        self.subAccountId = subAccountId
        self.takerFeeRate = takerFeeRate
        self.makerFeeRate = makerFeeRate
        self.price = price
        self.accountId = accountId
        self.timeInForce = timeInForce
        self.reduceOnly = reduceOnly
        self.triggerPrice = triggerPrice
        self.triggerPriceType = triggerPriceType
        self.trailingPercent = trailingPercent
        self.clientId = clientId
        self.timestampSeconds = timestampSeconds
        self.isPositionTpsl = isPositionTpsl
        self.signature = signature
        self.isOpenTpslOrder = isOpenTpslOrder
        self.isSetOpenSl = isSetOpenSl
        self.isSetOpenTp = isSetOpenTp
        self.slClientId = slClientId
        self.slPrice = slPrice
        self.slSide = slSide
        self.slSize = slSize
        self.slTriggerPrice = slTriggerPrice
        self.tpClientId = tpClientId
        self.tpPrice = tpPrice
        self.tpSide = tpSide
        self.tpSize = tpSize
        self.tpTriggerPrice = tpTriggerPrice
        self.slTriggerPrice = slTriggerPrice
        self.sourceFlag = sourceFlag
        self.brokerId = brokerId



================================================
FILE: apexomni/websocket_api.py
================================================
import json

from ._websocket_stream import _identify_ws_method, _make_public_kwargs, _WebSocketManager, \
    _ApexWebSocketManager, PUBLIC_WSS, PRIVATE_WSS

from concurrent.futures import ThreadPoolExecutor



class WebSocket(_ApexWebSocketManager):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)

        self.ws_public = None
        self.ws_private = None
        self.kwargs = kwargs
        self.public_kwargs = _make_public_kwargs(self.kwargs)

    def _ws_public_subscribe(self, sendStr, topic, callback):
        if not self.ws_public:
            self.ws_public = _ApexWebSocketManager(
                **self.public_kwargs)
            self.ws_public._connect(self.endpoint + PUBLIC_WSS)
        self.ws_public.subscribe(sendStr, topic, callback)

    def _ws_private_subscribe(self,topic, callback):
        if not self.ws_private:
            self.ws_private = _ApexWebSocketManager(
                **self.kwargs)
            self.ws_private._connect(self.endpoint + PRIVATE_WSS)
        self.ws_private.subscribe("", topic, callback)

    def custom_topic_stream(self, topic, callback, wss_url):
        subscribe = _identify_ws_method(
            wss_url,
            {
                PUBLIC_WSS: self._ws_public_subscribe,
                PRIVATE_WSS: self._ws_private_subscribe
            })
        subscribe(topic, callback)

    def depth_stream(self, callback, symbol, limit):
        """
        https://api-docs.pro.apex.exchange/#public-websocket-depth
        """
        arg = "orderBook" + str(limit) + ".H." + symbol
        topic = \
            {
                "op": "subscribe",
                "args": [arg]
            }
        topicStr = json.dumps(topic, sort_keys=True, separators=(",", ":"))
        self._ws_public_subscribe(topicStr, arg, callback)
    def unsub_depth_topic_stream(self, callback, arg):
        """
        https://api-docs.pro.apex.exchange/#public-websocket-depth
        """
        topic = \
            {
                "op": "unsubscribe",
                "args": [arg]
            }
        topicStr = json.dumps(topic, sort_keys=True, separators=(",", ":"))
        self._ws_public_subscribe(topicStr, arg, callback)
    def depth_topic_stream(self, callback, arg):
        """
        https://api-docs.pro.apex.exchange/#public-websocket-depth
        """
        topic = \
            {
                "op": "subscribe",
                "args": [arg]
            }
        topicStr = json.dumps(topic, sort_keys=True, separators=(",", ":"))
        self._ws_public_subscribe(topicStr, arg, callback)
    def ticker_stream(self, callback, symbol):
        """
        https://api-docs.pro.apex.exchange/#public-websocket-ticker
        """
        arg = "instrumentInfo" + ".H." + symbol
        topic = \
            {
                "op": "subscribe",
                "args": [arg]
            }
        topicStr = json.dumps(topic, sort_keys=True, separators=(",", ":"))
        self._ws_public_subscribe(topicStr, arg, callback)

    def all_ticker_stream(self, callback):
        """
        https://api-docs.pro.apex.exchange/#public-websocket-ticker
        """
        arg = "instrumentInfo.all"
        topic = \
            {
                "op": "subscribe",
                "args": [arg]
            }
        topicStr = json.dumps(topic, sort_keys=True, separators=(",", ":"))
        self._ws_public_subscribe(topicStr, arg, callback)

    def klines_stream(self, callback, symbol, interval):
        """
        https://api-docs.pro.apex.exchange/#public-websocket-candlestick-chart
        """
        arg = "candle" + "." + str(interval) + "." + symbol
        topic = \
            {
                "op": "subscribe",
                "args": [arg]
            }
        topicStr = json.dumps(topic, sort_keys=True, separators=(",", ":"))
        self._ws_public_subscribe(topicStr, arg, callback)

    def trade_stream(self, callback, symbol):
        """
       https://api-docs.pro.apex.exchange/#public-websocket-trade
        """
        arg = "recentlyTrade" + ".H." + symbol
        topic = \
            {
                "op": "subscribe",
                "args": [arg]
            }
        topicStr = json.dumps(topic, sort_keys=True, separators=(",", ":"))
        self._ws_public_subscribe(topicStr, arg, callback)


    def account_info_stream(self, callback):
        """
        https://api-docs.pro.apex.exchange/#private-websocket
        """
        topic = "ws_accounts_v1"
        self._ws_private_subscribe(topic=topic, callback=callback)

    def account_info_stream_v2(self, callback):
        """
        https://api-docs.pro.apex.exchange/#private-websocket
        """
        topic = "ws_accounts_v2"
        self._ws_private_subscribe(topic=topic, callback=callback)
    def account_info_stream_v3(self, callback):
        """
        https://api-docs.pro.apex.exchange/#private-websocket
        """
        topic = "ws_zk_accounts_v3"
        self._ws_private_subscribe(topic=topic, callback=callback)



================================================
FILE: apexomni/abi/erc20.json
================================================
[
    {
        "constant": true,
        "inputs": [],
        "name": "name",
        "outputs": [
            {
                "name": "",
                "type": "string"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    },
    {
        "constant": false,
        "inputs": [
            {
                "name": "_spender",
                "type": "address"
            },
            {
                "name": "_value",
                "type": "uint256"
            }
        ],
        "name": "approve",
        "outputs": [
            {
                "name": "",
                "type": "bool"
            }
        ],
        "payable": false,
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "constant": true,
        "inputs": [],
        "name": "totalSupply",
        "outputs": [
            {
                "name": "",
                "type": "uint256"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    },
    {
        "constant": false,
        "inputs": [
            {
                "name": "_from",
                "type": "address"
            },
            {
                "name": "_to",
                "type": "address"
            },
            {
                "name": "_value",
                "type": "uint256"
            }
        ],
        "name": "transferFrom",
        "outputs": [
            {
                "name": "",
                "type": "bool"
            }
        ],
        "payable": false,
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "constant": true,
        "inputs": [],
        "name": "decimals",
        "outputs": [
            {
                "name": "",
                "type": "uint8"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    },
    {
        "constant": true,
        "inputs": [
            {
                "name": "_owner",
                "type": "address"
            }
        ],
        "name": "balanceOf",
        "outputs": [
            {
                "name": "balance",
                "type": "uint256"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    },
    {
        "constant": true,
        "inputs": [],
        "name": "symbol",
        "outputs": [
            {
                "name": "",
                "type": "string"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    },
    {
        "constant": false,
        "inputs": [
            {
                "name": "_to",
                "type": "address"
            },
            {
                "name": "_value",
                "type": "uint256"
            }
        ],
        "name": "transfer",
        "outputs": [
            {
                "name": "",
                "type": "bool"
            }
        ],
        "payable": false,
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "constant": true,
        "inputs": [
            {
                "name": "_owner",
                "type": "address"
            },
            {
                "name": "_spender",
                "type": "address"
            }
        ],
        "name": "allowance",
        "outputs": [
            {
                "name": "",
                "type": "uint256"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    },
    {
        "payable": true,
        "stateMutability": "payable",
        "type": "fallback"
    },
    {
        "anonymous": false,
        "inputs": [
            {
                "indexed": true,
                "name": "owner",
                "type": "address"
            },
            {
                "indexed": true,
                "name": "spender",
                "type": "address"
            },
            {
                "indexed": false,
                "name": "value",
                "type": "uint256"
            }
        ],
        "name": "Approval",
        "type": "event"
    },
    {
        "anonymous": false,
        "inputs": [
            {
                "indexed": true,
                "name": "from",
                "type": "address"
            },
            {
                "indexed": true,
                "name": "to",
                "type": "address"
            },
            {
                "indexed": false,
                "name": "value",
                "type": "uint256"
            }
        ],
        "name": "Transfer",
        "type": "event"
    }
]



================================================
FILE: apexomni/abi/starkware-perpetuals.json
================================================
[
    {
        "payable": true,
        "stateMutability": "payable",
        "type": "fallback"
    },
    {
        "constant": true,
        "inputs": [],
        "name": "UPGRADE_DELAY_SLOT",
        "outputs": [
            {
                "internalType": "bytes32",
                "name": "",
                "type": "bytes32"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    },
    {
        "constant": true,
        "inputs": [],
        "name": "VERSION",
        "outputs": [
            {
                "internalType": "string",
                "name": "",
                "type": "string"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    },
    {
        "constant": true,
        "inputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "name": "configurationHash",
        "outputs": [
            {
                "internalType": "bytes32",
                "name": "",
                "type": "bytes32"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    },
    {
        "constant": true,
        "inputs": [],
        "name": "globalConfigurationHash",
        "outputs": [
            {
                "internalType": "bytes32",
                "name": "",
                "type": "bytes32"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    },
    {
        "constant": true,
        "inputs": [],
        "name": "implementation",
        "outputs": [
            {
                "internalType": "address",
                "name": "_implementation",
                "type": "address"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    },
    {
        "constant": false,
        "inputs": [
            {
                "internalType": "bytes",
                "name": "data",
                "type": "bytes"
            }
        ],
        "name": "initialize",
        "outputs": [],
        "payable": false,
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "anonymous": false,
        "inputs": [],
        "name": "LogFrozen",
        "type": "event"
    },
    {
        "anonymous": false,
        "inputs": [
            {
                "indexed": false,
                "internalType": "address",
                "name": "acceptedGovernor",
                "type": "address"
            }
        ],
        "name": "LogNewGovernorAccepted",
        "type": "event"
    },
    {
        "anonymous": false,
        "inputs": [
            {
                "indexed": false,
                "internalType": "address",
                "name": "nominatedGovernor",
                "type": "address"
            }
        ],
        "name": "LogNominatedGovernor",
        "type": "event"
    },
    {
        "anonymous": false,
        "inputs": [],
        "name": "LogNominationCancelled",
        "type": "event"
    },
    {
        "anonymous": false,
        "inputs": [
            {
                "indexed": false,
                "internalType": "address",
                "name": "entry",
                "type": "address"
            },
            {
                "indexed": false,
                "internalType": "string",
                "name": "entryId",
                "type": "string"
            }
        ],
        "name": "LogRegistered",
        "type": "event"
    },
    {
        "anonymous": false,
        "inputs": [
            {
                "indexed": false,
                "internalType": "address",
                "name": "entry",
                "type": "address"
            },
            {
                "indexed": false,
                "internalType": "string",
                "name": "entryId",
                "type": "string"
            }
        ],
        "name": "LogRemovalIntent",
        "type": "event"
    },
    {
        "anonymous": false,
        "inputs": [
            {
                "indexed": false,
                "internalType": "address",
                "name": "entry",
                "type": "address"
            },
            {
                "indexed": false,
                "internalType": "string",
                "name": "entryId",
                "type": "string"
            }
        ],
        "name": "LogRemoved",
        "type": "event"
    },
    {
        "anonymous": false,
        "inputs": [
            {
                "indexed": false,
                "internalType": "address",
                "name": "removedGovernor",
                "type": "address"
            }
        ],
        "name": "LogRemovedGovernor",
        "type": "event"
    },
    {
        "anonymous": false,
        "inputs": [],
        "name": "LogUnFrozen",
        "type": "event"
    },
    {
        "constant": true,
        "inputs": [],
        "name": "DEPOSIT_CANCEL_DELAY",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    },
    {
        "constant": true,
        "inputs": [],
        "name": "FREEZE_GRACE_PERIOD",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    },
    {
        "constant": true,
        "inputs": [],
        "name": "MAIN_GOVERNANCE_INFO_TAG",
        "outputs": [
            {
                "internalType": "string",
                "name": "",
                "type": "string"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    },
    {
        "constant": true,
        "inputs": [],
        "name": "MAX_FORCED_ACTIONS_REQS_PER_BLOCK",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    },
    {
        "constant": true,
        "inputs": [],
        "name": "MAX_VERIFIER_COUNT",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    },
    {
        "constant": true,
        "inputs": [],
        "name": "UNFREEZE_DELAY",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    },
    {
        "constant": true,
        "inputs": [],
        "name": "VERIFIER_REMOVAL_DELAY",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    },
    {
        "constant": false,
        "inputs": [
            {
                "internalType": "address",
                "name": "verifier",
                "type": "address"
            }
        ],
        "name": "announceAvailabilityVerifierRemovalIntent",
        "outputs": [],
        "payable": false,
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "constant": false,
        "inputs": [
            {
                "internalType": "address",
                "name": "verifier",
                "type": "address"
            }
        ],
        "name": "announceVerifierRemovalIntent",
        "outputs": [],
        "payable": false,
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "constant": true,
        "inputs": [],
        "name": "getRegisteredAvailabilityVerifiers",
        "outputs": [
            {
                "internalType": "address[]",
                "name": "_verifers",
                "type": "address[]"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    },
    {
        "constant": true,
        "inputs": [],
        "name": "getRegisteredVerifiers",
        "outputs": [
            {
                "internalType": "address[]",
                "name": "_verifers",
                "type": "address[]"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    },
    {
        "constant": true,
        "inputs": [
            {
                "internalType": "address",
                "name": "verifierAddress",
                "type": "address"
            }
        ],
        "name": "isAvailabilityVerifier",
        "outputs": [
            {
                "internalType": "bool",
                "name": "",
                "type": "bool"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    },
    {
        "constant": true,
        "inputs": [],
        "name": "isFrozen",
        "outputs": [
            {
                "internalType": "bool",
                "name": "frozen",
                "type": "bool"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    },
    {
        "constant": true,
        "inputs": [
            {
                "internalType": "address",
                "name": "verifierAddress",
                "type": "address"
            }
        ],
        "name": "isVerifier",
        "outputs": [
            {
                "internalType": "bool",
                "name": "",
                "type": "bool"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    },
    {
        "constant": false,
        "inputs": [],
        "name": "mainAcceptGovernance",
        "outputs": [],
        "payable": false,
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "constant": false,
        "inputs": [],
        "name": "mainCancelNomination",
        "outputs": [],
        "payable": false,
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "constant": true,
        "inputs": [
            {
                "internalType": "address",
                "name": "testGovernor",
                "type": "address"
            }
        ],
        "name": "mainIsGovernor",
        "outputs": [
            {
                "internalType": "bool",
                "name": "",
                "type": "bool"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    },
    {
        "constant": false,
        "inputs": [
            {
                "internalType": "address",
                "name": "newGovernor",
                "type": "address"
            }
        ],
        "name": "mainNominateNewGovernor",
        "outputs": [],
        "payable": false,
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "constant": false,
        "inputs": [
            {
                "internalType": "address",
                "name": "governorForRemoval",
                "type": "address"
            }
        ],
        "name": "mainRemoveGovernor",
        "outputs": [],
        "payable": false,
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "constant": false,
        "inputs": [
            {
                "internalType": "address",
                "name": "verifier",
                "type": "address"
            },
            {
                "internalType": "string",
                "name": "identifier",
                "type": "string"
            }
        ],
        "name": "registerAvailabilityVerifier",
        "outputs": [],
        "payable": false,
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "constant": false,
        "inputs": [
            {
                "internalType": "address",
                "name": "verifier",
                "type": "address"
            },
            {
                "internalType": "string",
                "name": "identifier",
                "type": "string"
            }
        ],
        "name": "registerVerifier",
        "outputs": [],
        "payable": false,
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "constant": false,
        "inputs": [
            {
                "internalType": "address",
                "name": "verifier",
                "type": "address"
            }
        ],
        "name": "removeAvailabilityVerifier",
        "outputs": [],
        "payable": false,
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "constant": false,
        "inputs": [
            {
                "internalType": "address",
                "name": "verifier",
                "type": "address"
            }
        ],
        "name": "removeVerifier",
        "outputs": [],
        "payable": false,
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "constant": false,
        "inputs": [],
        "name": "unFreeze",
        "outputs": [],
        "payable": false,
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "anonymous": false,
        "inputs": [
            {
                "indexed": false,
                "internalType": "address",
                "name": "depositorEthKey",
                "type": "address"
            },
            {
                "indexed": false,
                "internalType": "uint256",
                "name": "starkKey",
                "type": "uint256"
            },
            {
                "indexed": false,
                "internalType": "uint256",
                "name": "vaultId",
                "type": "uint256"
            },
            {
                "indexed": false,
                "internalType": "uint256",
                "name": "assetType",
                "type": "uint256"
            },
            {
                "indexed": false,
                "internalType": "uint256",
                "name": "nonQuantizedAmount",
                "type": "uint256"
            },
            {
                "indexed": false,
                "internalType": "uint256",
                "name": "quantizedAmount",
                "type": "uint256"
            }
        ],
        "name": "LogDeposit",
        "type": "event"
    },
    {
        "anonymous": false,
        "inputs": [
            {
                "indexed": false,
                "internalType": "uint256",
                "name": "starkKey",
                "type": "uint256"
            },
            {
                "indexed": false,
                "internalType": "uint256",
                "name": "vaultId",
                "type": "uint256"
            },
            {
                "indexed": false,
                "internalType": "uint256",
                "name": "assetId",
                "type": "uint256"
            }
        ],
        "name": "LogDepositCancel",
        "type": "event"
    },
    {
        "anonymous": false,
        "inputs": [
            {
                "indexed": false,
                "internalType": "uint256",
                "name": "starkKey",
                "type": "uint256"
            },
            {
                "indexed": false,
                "internalType": "uint256",
                "name": "vaultId",
                "type": "uint256"
            },
            {
                "indexed": false,
                "internalType": "uint256",
                "name": "assetType",
                "type": "uint256"
            },
            {
                "indexed": false,
                "internalType": "uint256",
                "name": "nonQuantizedAmount",
                "type": "uint256"
            },
            {
                "indexed": false,
                "internalType": "uint256",
                "name": "quantizedAmount",
                "type": "uint256"
            }
        ],
        "name": "LogDepositCancelReclaimed",
        "type": "event"
    },
    {
        "anonymous": false,
        "inputs": [
            {
                "indexed": false,
                "internalType": "uint256",
                "name": "starkKey",
                "type": "uint256"
            },
            {
                "indexed": false,
                "internalType": "uint256",
                "name": "vaultId",
                "type": "uint256"
            },
            {
                "indexed": false,
                "internalType": "uint256",
                "name": "assetType",
                "type": "uint256"
            },
            {
                "indexed": false,
                "internalType": "uint256",
                "name": "tokenId",
                "type": "uint256"
            },
            {
                "indexed": false,
                "internalType": "uint256",
                "name": "assetId",
                "type": "uint256"
            }
        ],
        "name": "LogDepositNftCancelReclaimed",
        "type": "event"
    },
    {
        "anonymous": false,
        "inputs": [
            {
                "indexed": false,
                "internalType": "uint256",
                "name": "starkKey",
                "type": "uint256"
            },
            {
                "indexed": false,
                "internalType": "uint256",
                "name": "tokenId",
                "type": "uint256"
            },
            {
                "indexed": false,
                "internalType": "uint256",
                "name": "nonQuantizedAmount",
                "type": "uint256"
            },
            {
                "indexed": false,
                "internalType": "uint256",
                "name": "quantizedAmount",
                "type": "uint256"
            },
            {
                "indexed": false,
                "internalType": "uint256",
                "name": "assetId",
                "type": "uint256"
            }
        ],
        "name": "LogMintWithdrawalPerformed",
        "type": "event"
    },
    {
        "anonymous": false,
        "inputs": [
            {
                "indexed": false,
                "internalType": "uint256",
                "name": "starkKey",
                "type": "uint256"
            },
            {
                "indexed": false,
                "internalType": "uint256",
                "name": "assetId",
                "type": "uint256"
            },
            {
                "indexed": false,
                "internalType": "uint256",
                "name": "quantizedAmount",
                "type": "uint256"
            }
        ],
        "name": "LogMintableWithdrawalAllowed",
        "type": "event"
    },
    {
        "anonymous": false,
        "inputs": [
            {
                "indexed": false,
                "internalType": "address",
                "name": "depositorEthKey",
                "type": "address"
            },
            {
                "indexed": false,
                "internalType": "uint256",
                "name": "starkKey",
                "type": "uint256"
            },
            {
                "indexed": false,
                "internalType": "uint256",
                "name": "vaultId",
                "type": "uint256"
            },
            {
                "indexed": false,
                "internalType": "uint256",
                "name": "assetType",
                "type": "uint256"
            },
            {
                "indexed": false,
                "internalType": "uint256",
                "name": "tokenId",
                "type": "uint256"
            },
            {
                "indexed": false,
                "internalType": "uint256",
                "name": "assetId",
                "type": "uint256"
            }
        ],
        "name": "LogNftDeposit",
        "type": "event"
    },
    {
        "anonymous": false,
        "inputs": [
            {
                "indexed": false,
                "internalType": "uint256",
                "name": "starkKey",
                "type": "uint256"
            },
            {
                "indexed": false,
                "internalType": "uint256",
                "name": "assetId",
                "type": "uint256"
            }
        ],
        "name": "LogNftWithdrawalAllowed",
        "type": "event"
    },
    {
        "anonymous": false,
        "inputs": [
            {
                "indexed": false,
                "internalType": "uint256",
                "name": "starkKey",
                "type": "uint256"
            },
            {
                "indexed": false,
                "internalType": "uint256",
                "name": "assetType",
                "type": "uint256"
            },
            {
                "indexed": false,
                "internalType": "uint256",
                "name": "tokenId",
                "type": "uint256"
            },
            {
                "indexed": false,
                "internalType": "uint256",
                "name": "assetId",
                "type": "uint256"
            },
            {
                "indexed": false,
                "internalType": "address",
                "name": "recipient",
                "type": "address"
            }
        ],
        "name": "LogNftWithdrawalPerformed",
        "type": "event"
    },
    {
        "anonymous": false,
        "inputs": [
            {
                "indexed": false,
                "internalType": "uint256",
                "name": "assetType",
                "type": "uint256"
            }
        ],
        "name": "LogSystemAssetType",
        "type": "event"
    },
    {
        "anonymous": false,
        "inputs": [
            {
                "indexed": false,
                "internalType": "address",
                "name": "tokenAdmin",
                "type": "address"
            }
        ],
        "name": "LogTokenAdminAdded",
        "type": "event"
    },
    {
        "anonymous": false,
        "inputs": [
            {
                "indexed": false,
                "internalType": "address",
                "name": "tokenAdmin",
                "type": "address"
            }
        ],
        "name": "LogTokenAdminRemoved",
        "type": "event"
    },
    {
        "anonymous": false,
        "inputs": [
            {
                "indexed": false,
                "internalType": "uint256",
                "name": "assetType",
                "type": "uint256"
            },
            {
                "indexed": false,
                "internalType": "bytes",
                "name": "assetInfo",
                "type": "bytes"
            }
        ],
        "name": "LogTokenRegistered",
        "type": "event"
    },
    {
        "anonymous": false,
        "inputs": [
            {
                "indexed": false,
                "internalType": "address",
                "name": "userAdmin",
                "type": "address"
            }
        ],
        "name": "LogUserAdminAdded",
        "type": "event"
    },
    {
        "anonymous": false,
        "inputs": [
            {
                "indexed": false,
                "internalType": "address",
                "name": "userAdmin",
                "type": "address"
            }
        ],
        "name": "LogUserAdminRemoved",
        "type": "event"
    },
    {
        "anonymous": false,
        "inputs": [
            {
                "indexed": false,
                "internalType": "address",
                "name": "ethKey",
                "type": "address"
            },
            {
                "indexed": false,
                "internalType": "uint256",
                "name": "starkKey",
                "type": "uint256"
            },
            {
                "indexed": false,
                "internalType": "address",
                "name": "sender",
                "type": "address"
            }
        ],
        "name": "LogUserRegistered",
        "type": "event"
    },
    {
        "anonymous": false,
        "inputs": [
            {
                "indexed": false,
                "internalType": "uint256",
                "name": "starkKey",
                "type": "uint256"
            },
            {
                "indexed": false,
                "internalType": "uint256",
                "name": "assetType",
                "type": "uint256"
            },
            {
                "indexed": false,
                "internalType": "uint256",
                "name": "nonQuantizedAmount",
                "type": "uint256"
            },
            {
                "indexed": false,
                "internalType": "uint256",
                "name": "quantizedAmount",
                "type": "uint256"
            }
        ],
        "name": "LogWithdrawalAllowed",
        "type": "event"
    },
    {
        "anonymous": false,
        "inputs": [
            {
                "indexed": false,
                "internalType": "uint256",
                "name": "starkKey",
                "type": "uint256"
            },
            {
                "indexed": false,
                "internalType": "uint256",
                "name": "assetType",
                "type": "uint256"
            },
            {
                "indexed": false,
                "internalType": "uint256",
                "name": "nonQuantizedAmount",
                "type": "uint256"
            },
            {
                "indexed": false,
                "internalType": "uint256",
                "name": "quantizedAmount",
                "type": "uint256"
            },
            {
                "indexed": false,
                "internalType": "address",
                "name": "recipient",
                "type": "address"
            }
        ],
        "name": "LogWithdrawalPerformed",
        "type": "event"
    },
    {
        "constant": false,
        "inputs": [
            {
                "internalType": "uint256",
                "name": "starkKey",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "assetType",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "vaultId",
                "type": "uint256"
            }
        ],
        "name": "deposit",
        "outputs": [],
        "payable": true,
        "stateMutability": "payable",
        "type": "function"
    },
    {
        "constant": false,
        "inputs": [
            {
                "internalType": "uint256",
                "name": "starkKey",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "assetType",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "vaultId",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "quantizedAmount",
                "type": "uint256"
            }
        ],
        "name": "deposit",
        "outputs": [],
        "payable": false,
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "constant": false,
        "inputs": [
            {
                "internalType": "uint256",
                "name": "starkKey",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "assetId",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "vaultId",
                "type": "uint256"
            }
        ],
        "name": "depositCancel",
        "outputs": [],
        "payable": false,
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "constant": false,
        "inputs": [
            {
                "internalType": "uint256",
                "name": "starkKey",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "assetType",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "vaultId",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "tokenId",
                "type": "uint256"
            }
        ],
        "name": "depositNft",
        "outputs": [],
        "payable": false,
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "constant": false,
        "inputs": [
            {
                "internalType": "uint256",
                "name": "starkKey",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "assetType",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "vaultId",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "tokenId",
                "type": "uint256"
            }
        ],
        "name": "depositNftReclaim",
        "outputs": [],
        "payable": false,
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "constant": false,
        "inputs": [
            {
                "internalType": "uint256",
                "name": "starkKey",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "assetId",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "vaultId",
                "type": "uint256"
            }
        ],
        "name": "depositReclaim",
        "outputs": [],
        "payable": false,
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "constant": true,
        "inputs": [
            {
                "internalType": "uint256",
                "name": "assetType",
                "type": "uint256"
            }
        ],
        "name": "getAssetInfo",
        "outputs": [
            {
                "internalType": "bytes",
                "name": "assetInfo",
                "type": "bytes"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    },
    {
        "constant": true,
        "inputs": [
            {
                "internalType": "uint256",
                "name": "starkKey",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "assetId",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "vaultId",
                "type": "uint256"
            }
        ],
        "name": "getCancellationRequest",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "request",
                "type": "uint256"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    },
    {
        "constant": true,
        "inputs": [
            {
                "internalType": "uint256",
                "name": "starkKey",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "assetId",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "vaultId",
                "type": "uint256"
            }
        ],
        "name": "getDepositBalance",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "balance",
                "type": "uint256"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    },
    {
        "constant": true,
        "inputs": [
            {
                "internalType": "uint256",
                "name": "starkKey",
                "type": "uint256"
            }
        ],
        "name": "getEthKey",
        "outputs": [
            {
                "internalType": "address",
                "name": "ethKey",
                "type": "address"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    },
    {
        "constant": true,
        "inputs": [
            {
                "internalType": "uint256",
                "name": "starkKey",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "vaultId",
                "type": "uint256"
            }
        ],
        "name": "getFullWithdrawalRequest",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "res",
                "type": "uint256"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    },
    {
        "constant": true,
        "inputs": [
            {
                "internalType": "uint256",
                "name": "starkKey",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "assetId",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "vaultId",
                "type": "uint256"
            }
        ],
        "name": "getQuantizedDepositBalance",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "balance",
                "type": "uint256"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    },
    {
        "constant": true,
        "inputs": [
            {
                "internalType": "uint256",
                "name": "presumedAssetType",
                "type": "uint256"
            }
        ],
        "name": "getQuantum",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "quantum",
                "type": "uint256"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    },
    {
        "constant": true,
        "inputs": [],
        "name": "getSystemAssetType",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    },
    {
        "constant": true,
        "inputs": [
            {
                "internalType": "uint256",
                "name": "starkKey",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "assetId",
                "type": "uint256"
            }
        ],
        "name": "getWithdrawalBalance",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "balance",
                "type": "uint256"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    },
    {
        "constant": true,
        "inputs": [
            {
                "internalType": "address",
                "name": "testedAdmin",
                "type": "address"
            }
        ],
        "name": "isTokenAdmin",
        "outputs": [
            {
                "internalType": "bool",
                "name": "",
                "type": "bool"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    },
    {
        "constant": true,
        "inputs": [
            {
                "internalType": "address",
                "name": "testedAdmin",
                "type": "address"
            }
        ],
        "name": "isUserAdmin",
        "outputs": [
            {
                "internalType": "bool",
                "name": "